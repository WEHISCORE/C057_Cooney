---
title: "Annotating the Cooney (C057) memory CD4+ T-cell data set"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: Single Cell Open Research Endeavour (SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: distill::distill_article
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(scater)
library(scran)
library(ggplot2)
library(cowplot)
library(edgeR)
library(Glimma)
library(BiocParallel)
library(patchwork)

source(here("code", "helper_functions.R"))

# NOTE: Using multiple cores seizes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 2L, 8L))
register(MulticoreParam(workers = getOption("mc.cores")))

knitr::opts_chunk$set(fig.path = "C057_Cooney.annotate_files/")
```

# Motivation

scRNA-seq has enabled an unprecedented level of granularity in characterizing gene expression changes in disease models.
The classification of clusters by cell type relies heavily on known marker genes and the annotation of clusters is typically performed manually, although (semi)automated methods are becoming available.

In ['Selection of biologically relevant cells for the Cooney (C057) memory CD4+ T-cell data set'](C057_Cooney.cell_selection.html) we annotated the cells with cell type labels using the [Database of Immune Cell Expression (`DICE`)](https://dice-database.org/) [@diceRef] reference dataset.
Here, we perform clustering and marker gene detection, which can be used for manual annotation of clusters.

In practice, some combination of manual and automated classification methods are usually necessary to properly annotate an scRNA-seq data set.

# Preparing the data

We start from the preprocessed *SingleCellExperiment* object created in ['Selection of biologically relevant cells for the Cooney (C057) memory CD4+ T-cell data set'](C057_Cooney.cell_selection.html).

```{r}
sce <- readRDS(here("data", "SCEs", "C057_Cooney.cells_selected.SCE.rds"))

# data frames containing co-ordinates and factors for creating reduced 
# dimensionality plots.
umap_df <- cbind(
  data.frame(
    x = reducedDim(sce, "UMAP")[, 1],
    y = reducedDim(sce, "UMAP")[, 2]),
  as.data.frame(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")]))

# Some useful colours
hto_cluster_colours <- setNames(
  unique(sce$hto_cluster_colours),
  unique(names(sce$hto_cluster_colours)))
hto_colours <- setNames(
  unique(sce$hto_colours),
  unique(names(sce$hto_colours)))
sample_colours <- setNames(
  unique(sce$sample_colours),
  unique(names(sce$sample_colours)))
treatment_colours <- setNames(
  unique(sce$treatment_colours),
  unique(names(sce$treatment_colours)))
cluster_colours <- setNames(
  unique(sce$cluster_colours),
  unique(names(sce$cluster_colours)))
label_main_collapsed_colours <- setNames(
  unique(sce$label_main_collapsed_colours),
  unique(names(sce$label_main_collapsed_colours)))
label_fine_collapsed_colours <- setNames(
  unique(sce$label_fine_collapsed_colours),
  unique(names(sce$label_fine_collapsed_colours)))

# Some useful gene sets
mito_set <- rownames(sce)[which(rowData(sce)$CHR == "MT")]
ribo_set <- grep("^RP(S|L)", rownames(sce), value = TRUE)
# NOTE: A more curated approach for identifying ribosomal protein genes 
#       (https://github.com/Bioconductor/OrchestratingSingleCellAnalysis-base/blob/ae201bf26e3e4fa82d9165d8abf4f4dc4b8e5a68/feature-selection.Rmd#L376-L380)
library(msigdbr)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2")
ribo_set <- union(
  ribo_set,
  c2_sets[c2_sets$gs_name == "KEGG_RIBOSOME", ]$human_gene_symbol)
```

# 'Mismatch' between clusters and 'fine' cell-level labels

As a reminder, Figure \@ref(fig:umap-with-fine-cell-labels) shows the 'fine' cell-levels labels and cluster labels we obtained in ['Selection of biologically relevant cells for the Cooney (C057) memory CD4+ T-cell data set'](C057_Cooney.cell_selection.html)

```{r umap-with-fine-cell-labels, fig.asp = 1 / 2, fig.cap = "UMAP plot. Each point represents a cluster and is coloured by the 'fine' cell-level label. Each panel highlights droplets from a particular predicted cluster type. Cluster labels with < 1% frequency are grouped together as `other`."}
p1 <- ggplot(aes(x = x, y = y), data = umap_df) +
  geom_point(
    aes(colour = cluster),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = cluster_colours) +
  scale_colour_manual(values = cluster_colours) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  ggtitle("Clusters")
bg <- dplyr::select(umap_df, -label_cell_fine_collapsed)
p2 <- ggplot(aes(x = x, y = y), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(
    aes(colour = label_cell_fine_collapsed),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = label_fine_collapsed_colours) +
  scale_colour_manual(values = label_fine_collapsed_colours) +
  theme_cowplot(font_size = 6) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ label_cell_fine_collapsed, ncol = 3) +
  guides(colour = FALSE) + 
  ggtitle("'Fine' cell-levl label")
p1 + p2 + plot_layout(widths = c(1, 1))
```

Two things are clear from Figure \@ref(fig:umap-with-fine-cell-labels):

1. There are regions of the UMAP plot that are enriched for certain 'fine' cell-level labels.
2. These regions do not correspond precisely to the clusters.

There are several reasons why these may not match up perfectly:

1. The choice of clustering resolution depends on the question being asked
2. The 'fine' cell-level labels do not make use of the clustering information
3. The genes driving the clustering are related to biological processes other than 'cell type' (e.g., T-cell activation, cell cycle, etc.) or technical factors

We touch on each of these issues in what follows.

# Choice of clustering resolution

A reminder that the relevant clustering resolution depends on the question being asked of the data.

<aside>
Clustering resolution is discussed in the 'Clustering' subsection of ['Selection of biologically relevant cells for the Cooney (C057) memory CD4+ T-cell data set'](C057_Cooney.cell_selection.html).
</aside>

The key parameter in our clustering procedure is called $k$.
The value of $k$ can be roughly interpreted as the anticipated size of the smallest subpopulation, with smaller values of $k$ generally yielding smaller, finer clusters.
If a subpopulation in the data has fewer than $k+1$ cells, then it is very unlikely that this subpopulation will form its own cluster

We provide results using a 'high' ($k=10$) and a 'low' ($k=200$) resolution clustering.

## Analysis

**TODO:** UP TO HERE. 'high' and 'low' resolution clustering of the data with summary figures. Might even try a subclustering approach.

# Cluster marker gene detection

## Motivation

To interpret our clustering results, we identify the genes that drive separation between clusters.
We focus on identifying genes that are more highly expressed in one cluster compared to all the other clusters (a.k.a. 'uniquely upregulated' or 'cluster-specific' marker genes).

These marker genes allow us to assign biological meaning to each cluster based on their functional annotation.
In the most obvious case, the marker genes for each cluster are *a priori* associated with particular cell types, allowing us to treat the clustering as a proxy for cell type identity.
The same principle can be applied to more subtle differences in activation status or differentiation state.

Identification of marker genes is usually based around the retrospective detection of differential expression between clusters^[Differential expression analyses is performed on the original log-expression values.].
Genes that are more strongly DE are more likely to have driven cluster separation in the first place.
The top DE genes are likely to be good candidate markers as they can effectively distinguish between cells in different clusters.

## Statistical methodology and considerations

It is important to have some understanding of the statistical methodology used for marker gene detection.
This section gives an overview.

### Gene lists

For each cluster, the DE results of the relevant comparisons are consolidated into a single output table.
This allows a set of marker genes to be easily defined by taking the top DE genes from each pairwise comparison between clusters.
Other statistics are also reported for each gene, including the adjusted p-values and the log-fold changes relative to every other cluster.

<aside>
It must be stressed that the (adjusted) p-values computed here cannot be properly interpreted as measures of significance because the clusters have been empirically identified from the data.
Nonetheless, they can still be used as way to rank 'interesting' genes.
</aside>

### Use of pairwise comparisons

We intentionally use pairwise comparisons between clusters rather than comparing each cluster to the average of all other cells.
The latter approach is sensitive to the population composition, potentially resulting in wildly different sets of markers when cell type abundances change in different contexts.
In the worst case, the presence of a single dominant subpopulation will drive the selection of top markers for every other cluster, pushing out useful genes that can resolve the various minor subpopulations.
Moreover, pairwise comparisons naturally provide more information to interpret of the utility of a marker, e.g., by providing log-fold changes to indicate which clusters are distinguished by this gene.

### Choice of test regime

The Welch $t$-test is an obvious choice of statistical method to test for differences in expression between clusters.
It is quickly computed and has good statistical properties for large numbers of cells [@soneson2018bias].

Alternatively, we could consider the Wilcoxon rank sum test (also known as the Wilcoxon-Mann-Whitney test, or WMW test).
Its strength lies in the fact that it directly assesses separation between the expression distributions of different clusters.
The WMW test statistic is proportional to the area-under-the-curve (AUC), i.e., the concordance probability, which is the probability of a random cell from one cluster having higher expression than a random cell from another cluster.
In a pairwise comparison, AUCs of 1 or 0 indicate that the two clusters have perfectly separated expression distributions. 
Thus, the WMW test directly addresses the most desirable property of a candidate marker gene, while the $t$-test only does so indirectly via the difference in the means and the intra-group variance.

The binomial test identifies genes that differ in the proportion of expressing cells between clusters^[For the purposes of this test, a cell is considered to express a gene simply if it has non-zero expression for that gene.].
This represents a much more stringent definition of marker genes compared to the other methods, as differences in expression between clusters are effectively ignored if both distributions of expression values are not near zero.
The premise is that genes are more likely to contribute to important biological decisions if they were active in one cluster and silent in another, compared to more subtle 'tuning' effects from changing the expression of an active gene.
From a practical perspective, a binary measure of presence/absence is easier to validate.

The Welch $t$-test is our default method for identifying marker genes.

### Blocking

We perform intra-sample comparisons by blocking on the `Sample` to avoid confounding effects from differential expression between samples^[Intra-sample comparisons are robust to differences between libraries but assume that each pair of clusters is present in at least one library. When this is not the case, we cannot commute a logFC for that pair of clusters.].

### Focus on cluster-specific marker genes

As noted above, we aim to identify genes that are more highly expressed in one cluster compared to all the other clusters (aka 'uniquely upregulated' or 'cluster-specific' marker genes)^[To achieve this, we use an intersection-union test [@berger1996bioequivalence] where the combined $p$-value for each gene is the maximum of the $p$-values from all pairwise comparisons. A gene will only achieve a low combined $p$-value if it is strongly upregulated in all comparisons to other clusters.].

This strategy will only report genes that are highly specific to the cluster of interest.
When it works, it can be highly effective as it generates a small focused set of candidate markers. 
However, any gene that is expressed at the same level in two or more clusters will simply not be detected. 
This is likely to discard many interesting genes, especially if the clusters are finely resolved with weak separation.

To give a concrete example, consider a mixed population of CD4^+^-only, CD8^+^-only, double-positive and double-negative T cells.
Using this strategy, neither _Cd4_ or _Cd8_ would be detected as subpopulation-specific markers because each gene is expressed in two subpopulations.
In comparison, a strategy that identified marker genes as those that are differentially expressed between *any* pair of clusters would identify these genes, albeit with these then appearing as marker genes for multiple clusters.

## Analysis

### $t$-test

```{r}
test.type <- "t"
```

#### Cluster-specific marker genes

```{r}
dir.create(
  here("output", "marker_genes", test.type, "uniquely_up"), recursive = TRUE)
```

CSV files of these cluster marker gene lists can be found in the [`output/marker_genes/t/uniquely_up/`](../output/marker_genes/t/uniquely_up/) directory.

```{r}
markers_uniquely_up <- findMarkers(
  sce,
  # TODO: Produce markers for both clustering resolutions
  groups = sce$cluster,
  block = sce$donor_id,
  pval.type = "all",
  direction = "up",
  test = test.type)
```

```{r}
message("Writing 'uniquely_up' marker genes to file.")
for (n in names(markers_union_any)) {
  message(n)
  gzout <- gzfile(
    description = here(
      "output", 
      "marker_genes", 
      test.type,
      "uniquely_up",
        # TODO: Produce markers for both clustering resolutions
      sprintf("cluster_%02d.%s.uniquely_up.csv.gz", as.integer(n), test)),
    open = "wb")
  write.table(
    x = markers_union_any[[n]] %>%
      as.data.frame() %>%
      tibble::rownames_to_column("gene_ID"), 
    file = gzout, 
    sep = ",", 
    quote = FALSE, 
    row.names = FALSE,
    col.names = TRUE)
  close(gzout)
}
```

```{r}
# TODO: Insert a heatmap highlighting the top-k cluster-specific markers (like 
#       I did in the EDA, below).
```

# Cell cycle

- [x] How to handle the 'cell cycle' looking cluster. Put in 'annotation'
     - [x] Perhaps exclude cell cycle genes from clustering? No, didn't make a difference.
     - "For example, regression would potentially remove interesting signal if cell cycle activity varied across clusters or conditions, with a prime example being the increased proliferation of activated T cells (Richard et al. 2018). We suggest only performing cell cycle adjustment on an as-needed basis in populations with clear cell cycle effects."
     - Highlight that this cluster has large library sizes

# Summary

**TODO:** Synthesis the results of SingleR, marker genes, and cell cycle analysis to arrive at `colLabels(sce)`.

# Concluding remarks

```{r}
saveRDS(
  sce,
  here("data", "SCEs", "C057_Cooney.annotated.SCE.rds"),
  compress = "xz")
```
The processed *SingleCellExperiment* object is available (see [`data/SCEs/C057_Cooney.annotated.SCE.rds`](../data/SCEs/C057_Cooney.annotated.SCE.rds)).
This will be used in downstream analyses, e.g., differential expression analysis between conditions within each cluster and differential abundance analyses between conditions for each cluster.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

```{r}
knitr::knit_exit()
```


# EDA of 'mismatch' between clusters and 'fine' cell-level labels

This was EDA and won't be included in the report

## Cluster resolution

```{r}
set.seed(256)
sce$cluster_k5 <- factor(
  igraph::cluster_louvain(
    buildSNNGraph(sce, use.dimred = "PCA", k = 5))$membership)
sce$cluster_k10 <- factor(
  igraph::cluster_louvain(
    buildSNNGraph(sce, use.dimred = "PCA", k = 10))$membership)
sce$cluster_k50 <- factor(
  igraph::cluster_louvain(
    buildSNNGraph(sce, use.dimred = "PCA", k = 50))$membership)
sce$cluster_k100 <- factor(
  igraph::cluster_louvain(
    buildSNNGraph(sce, use.dimred = "PCA", k = 100))$membership)
sce$cluster_k200 <- factor(
  igraph::cluster_louvain(
    buildSNNGraph(sce, use.dimred = "PCA", k = 200))$membership)

plot_grid(
  plotUMAP(sce, colour_by = "cluster_k5"),
  plotUMAP(sce, colour_by = "cluster_k10"),
  plotUMAP(sce, colour_by = "cluster_k50"),
  # plotUMAP(sce, colour_by = "cluster_k100"),
  plotUMAP(sce, colour_by = "cluster_k200"),
  plotUMAP(sce[, sce$Treatment == "Infected"], colour_by = "Treatment"),
  plotUMAP(sce[, sce$Treatment == "Uninfected"], colour_by = "Treatment"),
  ncol = 2)

sce$cluster_k500 <- factor(
  igraph::cluster_louvain(
    buildSNNGraph(sce, use.dimred = "PCA", k = 500))$membership)
z500 <- findMarkers(sce, groups = sce$cluster_k200, direction = "up", pval.type = "all")

z200 <- findMarkers(sce, groups = sce$cluster_k200, direction = "up", pval.type = "all")
z200[[1]][1:10, ]
z200[[2]][1:10, ]
z200[[3]][1:10, ]
z200[[4]][1:10, ]
# zz200 <- lapply(z200, function(x) rownames(x[x$FDR < 0.05, ]))
zz200 <- lapply(z200, function(x) {
  xx <- x[x$FDR < 0.05, ]
  rownames(xx[order(xx$summary.logFC, decreasing = TRUE), ])
})
lengths(zz200)

# TODO: Could add row annotations
plotHeatmap(
  sce,
  features = unlist(lapply(zz200, head, n = 10)),
  colour_columns_by = c("cluster_k200", "Treatment"),
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = c("cluster_k200", "Treatment"),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  zlim = c(-3, 3))

z100 <- findMarkers(sce, groups = sce$cluster_k100, direction = "up", pval.type = "all")
z100[[1]][1:10, ]
z100[[2]][1:10, ]
z100[[3]][1:10, ]
z100[[4]][1:10, ]
z100[[5]][1:10, ]
z100[[6]][1:10, ]
zz100 <- lapply(z100, function(x) rownames(x[x$FDR < 0.01, ]))
lengths(zz100)
plotHeatmap(
  sce,
  features = unlist(lapply(zz100, head, n = 5)),
  colour_columns_by = c("cluster_k100", "Treatment"),
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = c("cluster_k100", "Treatment"),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  zlim = c(-3, 3))

z10 <- findMarkers(sce, groups = sce$cluster_k10, direction = "up", pval.type = "all")
z10[[1]][1:10, ]
z10[[2]][1:10, ]
z10[[3]][1:10, ]
z10[[4]][1:10, ]
z10[[5]][1:10, ]
z10[[6]][1:10, ]
z10[[7]][1:10, ]
z10[[8]][1:10, ]
z10[[9]][1:10, ]
z10[[10]][1:10, ]
# zz10 <- lapply(z10, function(x) rownames(x[x$FDR < 0.01, ]))
zz10 <- lapply(z10, function(x) {
  xx <- x[x$FDR < 0.05, ]
  rownames(xx[order(xx$summary.logFC, decreasing = TRUE), ])
})
lengths(zz10)
plotHeatmap(
  sce,
  features = unlist(lapply(zz10, head, n = 5)),
  colour_columns_by = c("cluster_k10", "Treatment"),
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = c("cluster_k10", "Treatment"),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  zlim = c(-3, 3))

z5 <- 
z5[[1]][1:10, ]
z5[[2]][1:10, ]
z5[[3]][1:10, ]
z5[[4]][1:10, ]
z5[[5]][1:10, ]
z5[[6]][1:10, ]
z5[[7]][1:10, ]
z5[[8]][1:10, ]
z5[[9]][1:10, ]
z5[[10]][1:10, ]
z5[[11]][1:10, ]
z5[[12]][1:10, ]

zz5 <- lapply(z5, function(x) rownames(x[x$FDR < 0.01, ]))
lengths(zz5)
plotHeatmap(
  sce,
  features = unlist(lapply(zz5, head, n = 5)),
  colour_columns_by = c("cluster_k5", "Treatment"),
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = c("cluster_k5", "Treatment"),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  zlim = c(-3, 3))
```

## Cluster-level 'fine' labels

```{r}
pred_cluster_fine <- SingleR(
  test = sce,
  ref = ref,
  labels = labels_fine,
  method = "cluster",
  cluster = sce$cluster,
  BPPARAM = bpparam())
sce$label_cluster_fine <- factor(pred_cluster_fine$pruned.labels[sce$cluster])
sce$label_cluster_fine_collapsed <- .collapseLabel(
  sce$label_cluster_fine,
  sce$batch)
umap_df$label_cluster_fine_collapsed <- sce$label_cluster_fine_collapsed

bg <- dplyr::select(umap_df, -label_cluster_fine_collapsed)
p3 <- ggplot(aes(x = x, y = y), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(
    aes(colour = label_cluster_fine_collapsed),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = label_fine_collapsed_colours) +
  scale_colour_manual(values = label_fine_collapsed_colours) +
  theme_cowplot(font_size = 6) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ label_cluster_fine_collapsed, ncol = 3) +
  guides(colour = FALSE) + 
  ggtitle("'Fine' cluster-levl label")

p1 + (p3 + p2 + plot_layout(nrow = 2, heights = c(1, 3)))
```
