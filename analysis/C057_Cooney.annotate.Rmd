---
title: "Annotating the Cooney (C057) memory CD4+ T-cell data set"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: Single Cell Open Research Endeavour (SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: distill::distill_article
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(scater)
library(scran)
library(ggplot2)
library(cowplot)
library(edgeR)
library(Glimma)
library(BiocParallel)
library(patchwork)

source(here("code", "helper_functions.R"))

# NOTE: Using multiple cores seizes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 2L, 8L))
register(MulticoreParam(workers = getOption("mc.cores")))

knitr::opts_chunk$set(fig.path = "C057_Cooney.annotate_files/")
```

# Preparing the data

We start from the preprocessed *SingleCellExperiment* object created in ['Selection of biologically relevant cells for the Cooney (C057) memory CD4+ T-cell data set'](C057_Cooney.cell_selection.html).

```{r}
sce <- readRDS(here("data", "SCEs", "C057_Cooney.cells_selected.SCE.rds"))

# data frames containing co-ordinates and factors for creating reduced 
# dimensionality plots.
umap_df <- cbind(
  data.frame(
    x = reducedDim(sce, "UMAP")[, 1],
    y = reducedDim(sce, "UMAP")[, 2]),
  as.data.frame(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")]))

# Some useful colours
sample_colours <- setNames(
  unique(sce$sample_colours),
  unique(names(sce$sample_colours)))
treatment_colours <- setNames(
  unique(sce$treatment_colours),
  unique(names(sce$treatment_colours)))
cluster_colours <- setNames(
  unique(sce$cluster_colours),
  unique(names(sce$cluster_colours)))
label_main_collapsed_colours <- setNames(
  unique(sce$label_main_collapsed_colours),
  unique(names(sce$label_main_collapsed_colours)))
label_fine_collapsed_colours <- setNames(
  unique(sce$label_fine_collapsed_colours),
  unique(names(sce$label_fine_collapsed_colours)))

# Some useful gene sets
mito_set <- rownames(sce)[which(rowData(sce)$CHR == "MT")]
ribo_set <- grep("^RP(S|L)", rownames(sce), value = TRUE)
# NOTE: A more curated approach for identifying ribosomal protein genes 
#       (https://github.com/Bioconductor/OrchestratingSingleCellAnalysis-base/blob/ae201bf26e3e4fa82d9165d8abf4f4dc4b8e5a68/feature-selection.Rmd#L376-L380)
library(msigdbr)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2")
ribo_set <- union(
  ribo_set,
  c2_sets[c2_sets$gs_name == "KEGG_RIBOSOME", ]$human_gene_symbol)
```


# Motivation

The most challenging task in scRNA-seq data analysis is arguably the annotation of cells with meaningful labels.
We might attempt to label cells individually or to label clusters (with cells assigned to those clusters 'inheriting' the cluster-level label).

In ['Selection of biologically relevant cells for the Cooney (C057) memory CD4+ T-cell data set'](C057_Cooney.cell_selection.html), we obtained two sets of labels:

1. 'cell-type' labels using `r BiocStyle::Biocpkg("SingleR")`. These labels can be very useful, but are limited by the resolution of the reference dataset(s). For example, the cell-type labels we obtained are unlikely to be able to distinguish more subtle differences between cells, such as changes in activation or differentiation state.
2. 'cluster' labels using clustering. Obtaining clusters of cells is fairly straightforward, but it is more difficult to determine what biological state is represented by each of those clusters.

These two sets of labels need not be in perfect agreement.
For example, Figure \@ref(fig:umap-with-clusters-and-fine-labels) shows that there are regions of the UMAP plot that are enriched for certain `r BiocStyle::Biocpkg("SingleR")` labels but that these regions do not always correspond precisely to the cluster labels.

```{r umap-with-clusters-and-fine-labels, fig.asp = 1 / 2, fig.cap = "UMAP plot. Each point represents a cluster and is coloured by the 'fine' cell-level label. Each panel highlights droplets from a particular predicted cluster type. Cluster labels with < 1% frequency are grouped together as `other`."}
p_cluster <- ggplot(aes(x = x, y = y), data = umap_df) +
  geom_point(
    aes(colour = cluster),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = cluster_colours) +
  scale_colour_manual(values = cluster_colours) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  ggtitle("Clusters")

bg <- dplyr::select(umap_df, -label_cell_fine)
p_label_cell_fine <- ggplot(aes(x = x, y = y), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(
    aes(colour = label_cell_fine_collapsed),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = label_fine_collapsed_colours) +
  scale_colour_manual(values = label_fine_collapsed_colours) +
  theme_cowplot(font_size = 4) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ label_cell_fine, ncol = 4) +
  guides(colour = FALSE) + 
  ggtitle("'Fine' cell-level label")

p_cluster + p_label_cell_fine + plot_layout(widths = c(1, 4 / 3))
```

More importantly, this 'disagreement' between the two sets of labels need not be cause for concern because there are several reasons why these may not match up, including:

1. The genes driving the cluster labels may be different to the genes driving the `r BiocStyle::Biocpkg("SingleR")` labels. For example, the genes driving the clustering may be related to biological processes other than 'cell type' (e.g., T-cell activation, cell cycle, etc.).
2. The choice of clustering resolution depends on the question being asked (i.e. it may be focused on sub-cell type details or super-cell-type details).
3. The cell-level labels do not make use of the clustering information and so may be noisy.

In practice, a combination of automated and manual classification methods are usually necessary to properly annotate an scRNA-seq data set.

In this section we identify the genes that drive separation between clusters to help us interpret the clustering results.

# Cluster marker gene detection

## Motivation

To interpret our clustering results, we identify the genes that drive separation between clusters.
We focus on identifying genes that are more highly expressed in one cluster compared to all the other clusters (a.k.a. 'uniquely upregulated' or 'cluster-specific' marker genes).

These marker genes allow us to assign biological meaning to each cluster based on their functional annotation.
In the most obvious case, the marker genes for each cluster are *a priori* associated with particular cell types, allowing us to treat the clustering as a proxy for cell type identity.
The same principle can be applied to more subtle differences in activation status or differentiation state.

Identification of marker genes is usually based around the retrospective detection of differential expression between clusters^[Differential expression analyses is performed on the original log-expression values.].
Genes that are more strongly DE are more likely to have driven cluster separation in the first place.
The top DE genes are likely to be good candidate markers as they can effectively distinguish between cells in different clusters.

## Statistical methodology and considerations

It is important to have some understanding of the statistical methodology used for marker gene detection.
This section gives an overview.

### Gene lists

For each cluster, the DE results of the relevant comparisons are consolidated into a single output table.
This allows a set of marker genes to be easily defined by taking the top DE genes from each pairwise comparison between clusters.
Other statistics are also reported for each gene, including the adjusted p-values^[It must be stressed that the (adjusted) p-values computed here cannot be properly interpreted as measures of significance because the clusters have been empirically identified from the data. Nonetheless, they can still be used as way to rank 'interesting' genes.] and the log-fold changes relative to every other cluster.

### Use of pairwise comparisons

We intentionally use pairwise comparisons between clusters rather than comparing each cluster to the average of all other cells.
The latter approach is sensitive to the population composition, potentially resulting in wildly different sets of markers when cell type abundances change in different contexts.
In the worst case, the presence of a single dominant subpopulation will drive the selection of top markers for every other cluster, pushing out useful genes that can resolve the various minor subpopulations.
Moreover, pairwise comparisons naturally provide more information to interpret of the utility of a marker, e.g., by providing log-fold changes to indicate which clusters are distinguished by this gene.

### Choice of test statistic

The Welch $t$-test is an obvious choice of statistical method to test for differences in expression between clusters.
It is quickly computed and has good statistical properties for large numbers of cells [@soneson2018bias].

Alternatively, we could consider the Wilcoxon rank sum test (also known as the Wilcoxon-Mann-Whitney test, or WMW test).
Its strength lies in the fact that it directly assesses separation between the expression distributions of different clusters.
The WMW test statistic is proportional to the area-under-the-curve (AUC), i.e., the concordance probability, which is the probability of a random cell from one cluster having higher expression than a random cell from another cluster.
In a pairwise comparison, AUCs of 1 or 0 indicate that the two clusters have perfectly separated expression distributions. 
Thus, the WMW test directly addresses the most desirable property of a candidate marker gene, while the $t$-test only does so indirectly via the difference in the means and the intra-group variance.

Another alternative, the binomial test, identifies genes that differ in the proportion of expressing cells between clusters^[For the purposes of this test, a cell is considered to express a gene simply if it has one or more counts for that gene.].
This represents a much more stringent definition of marker genes compared to the other methods, as differences in expression between clusters are effectively ignored if both distributions of expression values are not near zero.
The premise is that genes are more likely to contribute to important biological decisions if they were active in one cluster and silent in another, compared to more subtle 'tuning' effects from changing the expression of an active gene.
From a practical perspective, a binary measure of presence/absence is easier to validate.

The Welch $t$-test is our default method for identifying marker genes.

### Blocking

We perform intra-sample comparisons by blocking on the `Sample` to avoid confounding effects from differential expression between samples^[Intra-sample comparisons are robust to differences between libraries but assume that each pair of clusters is present in at least one library. When this is not the case, we cannot commute a logFC for that pair of clusters.].

### Focus on cluster-specific marker genes

As noted above, we aim to identify genes that are more highly expressed in one cluster compared to all the other clusters (aka 'uniquely upregulated' or 'cluster-specific' marker genes)^[To achieve this, we use an intersection-union test [@berger1996bioequivalence] where the combined $p$-value for each gene is the maximum of the $p$-values from all pairwise comparisons. A gene will only achieve a low combined $p$-value if it is strongly upregulated in all comparisons to other clusters.].

This strategy will only report genes that are highly specific to the cluster of interest.
When it works, it can be highly effective as it generates a small focused set of candidate markers. 
However, any gene that is expressed at the same level in two or more clusters will simply not be detected. 
This is likely to discard many interesting genes, especially if the clusters are finely resolved with weak separation.

To give a concrete example, consider a mixed population of CD4^+^-only, CD8^+^-only, double-positive and double-negative T cells.
Using this strategy, neither _Cd4_ or _Cd8_ would be detected as subpopulation-specific markers because each gene is expressed in two subpopulations.
In comparison, a strategy that identified marker genes as those that are differentially expressed between *any* pair of clusters would identify these genes, albeit with these then appearing as marker genes for multiple clusters.

## Analysis

### $t$-test

```{r}
test.type <- "t"
```

#### Cluster-specific marker genes

```{r}
markers_uniquely_up <- findMarkers(
  sce,
  groups = sce$cluster,
  block = sce$donor_id,
  pval.type = "all",
  direction = "up",
  test = test.type)
```

CSV files of these cluster marker gene lists can be found in the [`output/marker_genes/t/uniquely_up/`](../output/marker_genes/t/uniquely_up/) directory.

```{r}
dir.create(
  here("output", "marker_genes", test.type, "uniquely_up"), recursive = TRUE)
message("Writing 'uniquely_up' marker genes to file.")
for (cluster in levels(sce$cluster)) {
  message(cluster)
  gzout <- gzfile(
    description = here(
      "output", 
      "marker_genes", 
      test.type,
      "uniquely_up",
      sprintf(
        "cluster_%02d.%s.uniquely_up.csv.gz",
        as.integer(cluster),
        test.type)),
    open = "wb")
  write.table(
    x = markers_uniquely_up[[cluster]] %>%
      as.data.frame() %>%
      tibble::rownames_to_column("gene_ID"), 
    file = gzout, 
    sep = ",", 
    quote = FALSE, 
    row.names = FALSE,
    col.names = TRUE)
  close(gzout)
}
```

```{r}
k <- 10
```

As an example of the information available in these gene lists, Figure \@ref(fig:cluster-markers-heatmap) is heatmap showing the expression of the top-`r k` cluster-specific marker genes across the dataset.

```{r cluster-markers-heatmap, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values of top-10 cluster-specific marker genes for each cluster. Each column is a sample, each row a gene", fig.asp = 1.5}
markers <- lapply(markers_uniquely_up, function(x) {
  xx <- x[x$FDR < 0.05, ]
  rownames(xx[order(xx$summary.logFC, decreasing = TRUE), ])
})

# NOTE: The code below basically does what the commented out code does but 
#       allows me to provide annotation_colors.
# plotHeatmap(
#   sce,
#   features = unlist(lapply(markers, head, n = k)),
#   colour_columns_by = c("cluster", "Treatment"),
#   center = TRUE,
#   symmetric = TRUE,
#   order_columns_by = c("cluster", "Treatment"),
#   cluster_rows = FALSE,
#   cluster_cols = FALSE,
#   zlim = c(-3, 3))
k <- 10
features <- unlist(lapply(markers, head, n = k))
mat <- logcounts(sce)[features, ]
mat <- mat - rowMeans(mat)
zlim <- c(-3, 3)
mat[mat < zlim[1]] <- zlim[1]
mat[mat > zlim[2]] <- zlim[2]
library(pheatmap)
o <- order(sce$cluster, sce$Treatment)
pheatmap(
  mat = mat[, o],
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_colnames = FALSE,
  annotation_row = data.frame(
    cluster = rep(levels(sce$cluster), each = k),
    row.names = features),
  annotation_col = data.frame(
    cluster = sce$cluster[o],
    Treatment = sce$Treatment[o],
    row.names = colnames(sce)[o]),
  annotation_colors = list(
    cluster = cluster_colours[levels(sce$cluster)],
    Treatment = treatment_colours))
```

## Summary

The provided cluster marker gene lists can be analysed like any other gene list, such as by using gene set enrichment analysis against the Gene Ontology (GO) or Kyoto Encyclopedia of Genes and Genomes (KEGG) databases.
We strongly recommend that you visualise the expression patterns of any genes of interest to better understand what is driving their inclusion in the marker gene lists.

<aside>
The `r BiocStyle::Biocpkg("iSEE")` package may be useful for visualizing the expression patterns of these genes. Please let me know if you would like a lesson in how to use it.
</aside>

If the provided gene lists are insufficient for annotating the clusters, we may consider other strategies for identifying cluster marker genes.
As previously mentioned, these could be a different choice of test statistic or a different choice of strategy for combining the pairwise differential expression results into a marker list.
To better characterise specific clusters, it may also be necessary to perform differential expression analysis between a selected subset of clusters.

If the clusters themselves are thought to be inadequate, we can use a different clustering resolution and repeat the entire process.

# Cell cycle

**TODO**: UP TO HERE

- [ ] Just look at cyclins
- [x] How to handle the 'cell cycle' looking cluster. Put in 'annotation'
     - [x] Perhaps exclude cell cycle genes from clustering? No, didn't make a difference.
     - "For example, regression would potentially remove interesting signal if cell cycle activity varied across clusters or conditions, with a prime example being the increased proliferation of activated T cells (Richard et al. 2018). We suggest only performing cell cycle adjustment on an as-needed basis in populations with clear cell cycle effects."
     - Highlight that this cluster has large library sizes

# Summary

**TODO:** Synthese the results of SingleR, marker genes, and cell cycle analysis to arrive at `colLabels(sce)`.

# Concluding remarks

```{r}
# TODO: Is this object any different to the cell_selected version?
saveRDS(
  sce,
  here("data", "SCEs", "C057_Cooney.annotated.SCE.rds"),
  compress = "xz")
```
The processed *SingleCellExperiment* object is available (see [`data/SCEs/C057_Cooney.annotated.SCE.rds`](../data/SCEs/C057_Cooney.annotated.SCE.rds)).
This will be used in downstream analyses, e.g., differential expression analysis between conditions within each cluster and differential abundance analyses between conditions for each cluster.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

```{r}
knitr::knit_exit()
```
