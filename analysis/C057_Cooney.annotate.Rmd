---
title: "Annotating the Cooney (C057)  memory CD4 T-cell data set"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: Single Cell Open Research Endeavour (SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: radix::radix_article
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(rmarkdown)
library(BiocStyle)
library(scran)
library(janitor)
library(ggplot2)
library(cowplot)

source(here("analysis", "helper_functions.R"))

# NOTE: Using multiple cores siezes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 1L, 9L))
register(MulticoreParam(workers = getOption("mc.cores")))

knitr::opts_chunk$set(fig.path = "C057_Cooney_annotate_files/")
```

# Introduction

```{r}
sce <- readRDS(here("data", "SCEs", "C057_Cooney.preprocessed.SCE.rds"))
```

```{r}
# data frames containing co-ordinates and factors for creating reduced 
# dimensionality plots.
tsne_df <- cbind(
  data.frame(
    x = reducedDim(sce, "TSNE")[, 1],
    y = reducedDim(sce, "TSNE")[, 2]),
  as.data.frame(colData(sce)))
```

```{r}
hto_to_sample_df <- as.data.frame(colData(sce)) %>%
  dplyr::select(hto_cluster, HTO, Sample, Treatment, Replicate) %>%
  dplyr::distinct()

# Some useful colours
hto_cluster_colours <- setNames(
  colorblindr::palette_OkabeIto,
  levels(sce$hto_cluster))
hto_cluster_colours <- hto_cluster_colours[!is.na(names(hto_cluster_colours))]
hto_colours <- hto_cluster_colours
names(hto_colours) <- dplyr::inner_join(
  data.frame(hto_cluster = names(hto_cluster_colours)),
  hto_to_sample_df) %>%
  dplyr::pull(HTO)
sample_colours <- hto_cluster_colours
names(sample_colours) <- dplyr::inner_join(
  data.frame(hto_cluster = names(sample_colours)),
  hto_to_sample_df) %>%
  dplyr::pull(Sample)
treatment_colours <- c(
  "Infected" = "#e41a1c",
  "Uninfected" = "#377eb8",
  "Unknown" = "grey70")
# NOTE: No replicate_colours because we won't ever colour by this.
```

```{r}
dir.create(here("data", "marker_genes"))
dir.create(here("output", "marker_genes"))
```

scRNA-seq has enabled an unprecedented level of granularity in characterizing gene expression changes in disease models.
The classification of clusters by cell type relies heavily on known marker genes and the annotation of clusters is typically performed manually, although (semi)automated methods are becoming available.

Here, we perform clustering and marker gene detection, which can be used for manual annotation of clusters, along with an automated annotation method.
In practice, some combination of manual and automated classification methods are usually necessary to properly annotate an scRNA-seq data set.

# Preparing the data

We start from the preprocessed *SingleCellExperiment* object created in ['Merging the Cooney (C057) M-cell data set'](C057_Cooney_merge.html).

# Clustering cells

Clustering is an unsupervised learning procedure that is used in scRNA-seq data analysis to empirically define groups of cells with similar expression profiles.
Its primary purpose is to summarize the data in a digestible format for human interpretation. 
This allows us to describe population heterogeneity in terms of discrete labels that are easily understood, rather than attempting to comprehend the high-dimensional manifold on which the cells truly reside.
After annotation based on marker genes, the clusters can be treated as proxies for more abstract biological concepts such as cell types or states.
Clustering is thus a critical step for extracting biological insights from scRNA-seq data.

## Clusters vs. cell types

It is worth stressing the distinction between clusters and cell types.
The former is an empirical construct while the latter is a biological truth (albeit a vaguely defined one).
For this reason, questions like "what is the true number of clusters?" are usually meaningless.
We can define as many clusters as we like, with whatever algorithm we like - each clustering will represent its own partitioning of the high-dimensional expression space, and is as "real" as any other clustering.

A more relevant question is "how well do the clusters approximate the cell types?"
Unfortunately, this is difficult to answer given the context-dependent interpretation of biological truth.
Some analysts will be satisfied with resolution of the major cell types; other analysts may want resolution of subtypes; and others still may require resolution of different states (e.g., metabolic activity, stress) within those subtypes.
Two clusterings can also be highly inconsistent yet both valid, simply partitioning the cells based on different aspects of biology.
Indeed, asking for an unqualified "best" clustering is akin to asking for the best magnification on a microscope without any context.

It is helpful to realize that clustering, like a microscope, is simply a tool to explore the data.
We can zoom in and out by changing the resolution of the clustering parameters, and we can experiment with different clustering algorithms to obtain alternative perspectives of the data.
This iterative approach is entirely permissible for data exploration, which constitutes the majority of all scRNA-seq data analysis.

## Graph-based clustering

We build a shared nearest neighbour graph [@xu2015identification] and use the Louvain algorithm to identify clusters.
We build the graph using the principal components.

```{r}
set.seed(46783)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
tsne_df$cluster <- sce$cluster
cluster_colours <- setNames(
  Polychrome::dark.colors(nlevels(sce$cluster)),
  levels(sce$cluster))
```

There are `r length(levels(sce$cluster))` clusters detected, summarised in Figure \@ref(fig:cluster-barplot).

```{r cluster-barplot, fig.asp = 1 / 3, fig.cap = "Breakdown of clusters by experimental factors.", layout = "l-page"}
plot_grid(
  ggplot(as.data.frame(colData(sce))) + 
    geom_bar(
      aes(x = cluster, fill = Treatment),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = treatment_colours) +
    theme_cowplot(font_size = 8),
  ggplot(as.data.frame(colData(sce))) + 
    geom_bar(
      aes(x = cluster, fill = Sample),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = sample_colours) +
    theme_cowplot(font_size = 8),
  ggplot(as.data.frame(colData(sce))) + 
    geom_bar(aes(x = cluster, fill = cluster)) +
    coord_flip() +
    ylab("Number of cells") +
    scale_fill_manual(values = cluster_colours) +
    theme_cowplot(font_size = 8),
  align = "h",
  ncol = 3)
```

### Assessing cluster separation

We look at the ratio of the observed and expected edge weights to confirm that the clusters are modular. 
Figure \@ref(fig:clustermod) indicates some cluster overlap, with the large-ish non-zero off-diagonal entries.

```{r clustermod, fig.cap = "Heatmap of the log~10~-ratio of the total weight between nodes in the same cluster or in different clusters, relative to the total weight expected under a null model of random links.", fig.asp = 0.8}
cluster_mod <- clusterModularity(
  graph = snn_gr, 
  clusters = sce$cluster, 
  get.values = TRUE)
log_ratio <- log2(cluster_mod$observed / cluster_mod$expected + 1)
library(pheatmap)
pheatmap(
  mat = log_ratio,
  cluster_rows = FALSE, 
  cluster_cols = FALSE, 
  color = colorRampPalette(c("white", "blue"))(100))
```

## Visual inspection of clustering results

Figure \@ref(fig:clusterplot-tsne) shows the cluster labels on a t-SNE plot to confirm that a sensible partitioning was generated.

```{r clusterplot-tsne, fig.cap = "t-SNE plot of the t-SNE data, where each point represents a cell and is coloured according to the legend.", layout = "l-page", fig.asp = 1}
plot_grid(
  ggplot(aes(x = x, y = y), data = tsne_df) +
    geom_point(aes(colour = cluster), size = 0.25) +
    scale_colour_manual(values = cluster_colours) + 
    theme_cowplot(font_size = 10) + 
    ggtitle("t-SNE") +
    xlab("Dimension 1") + 
    ylab("Dimension 2"),
  ggplot(aes(x = x, y = y), data = tsne_df) +
    geom_point(aes(colour = Treatment), size = 0.25) +
    theme_cowplot(font_size = 10) + 
    ggtitle("t-SNE") +
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = treatment_colours),
  ggplot(aes(x = x, y = y), data = tsne_df) +
    geom_point(aes(colour = Sample), size = 0.25) +
    theme_cowplot(font_size = 10) + 
    ggtitle("t-SNE") +
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = sample_colours),
  ncol = 2, 
  align = "v")
```

# Marker gene detection

To interpret our clustering results, we identify the genes that drive separation between clusters.
These marker genes allow us to assign biological meaning to each cluster based on their functional annotation.
In the most obvious case, the marker genes for each cluster are *a priori* associated with particular cell types, allowing us to treat the clustering as a proxy for cell type identity.
The same principle can be applied to more subtle differences in activation status or differentiation state.

Identification of marker genes is usually based around the retrospective detection of differential expression between clusters^[Differential expression analyses is performed on the original log-expression values.We do not use the MNN-corrected values here except to obtain the clusters to be characterized.].
Genes that are more strongly DE are more likely to have driven cluster separation in the first place.
The top DE genes are likely to be good candidate markers as they can effectively distinguish between cells in different clusters.

## Using pairwise $t$-tests

### Standard application

The Welch $t$-test is an obvious choice of statistical method to test for differences in expression between clusters.
It is quickly computed and has good statistical properties for large numbers of cells [@soneson2018bias].
We perform intra-samples comparisons by blocking on the sample of origin to avoid confounding effects from library-to-library variability or differential expression between samples^[Intra-sample comparisons are robust to differences between libraries but assume that each pair of clusters is present in at least one library. When this is not the case, we cannot commute a logFC for that pair of clusters.].

For each cluster, the DE results of the relevant comparisons are consolidated into a single output table.
This allows a set of marker genes to be easily defined by taking the top DE genes from each pairwise comparison between clusters.
Other statistics are also reported for each gene, including the adjusted p-values^[It must be stressed that the (adjusted) p-values computed here cannot be properly interpreted as measures of significance because the clusters have been empirically identified from the data.
Nonetheless, they can still be used as way to rank 'interesting' genes.] and the log-fold changes relative to every other cluster.

```{r}
markers_union_any <- findMarkers(
  sce, 
  clusters = sce$cluster,
  block = sce$Sample,
  pval.type = "any",
  direction = "any")
saveRDS(
  markers_union_any, 
  here("data", "marker_genes", "C057_Cooney.markers_union_any.rds"),
  compress = "xz")
dir.create(here("output", "marker_genes", "union_any"))
message("Writing 'union_any' marker genes to file.")
for (n in names(markers_union_any)) {
  message(n)
  gzout <- gzfile(
    description = here(
      "output", 
      "marker_genes", 
      "union_any",
      paste0("cluster_", n, ".union_any.csv.gz")),
    open = "wb")
  write.table(
    x = markers_union_any[[n]] %>%
      as.data.frame() %>%
      tibble::rownames_to_column("gene_ID"), 
    file = gzout, 
    sep = ",", 
    quote = FALSE, 
    row.names = FALSE,
    col.names = TRUE)
  close(gzout)
}
```

```{r}
chosen <- "3"
interesting <- markers_union_any[[chosen]]
# TODO: Add sanity check
```

To demonstrate, we use cluster `r chosen` as our cluster of interest for this section.
The relevant table contains log~2~-fold changes of expression in cluster `r chosen` over each other cluster, along with several statistics obtained by combining $p$-values [@simes1986improved] across the pairwise comparisons involving `r chosen`.

```{r}
.adf(head(interesting, 10)) %>%
  tibble::rownames_to_column("Gene") %>%
  knitr::kable(
    caption = paste0(
      "First 10 marker genes for cluster ",
      chosen,
      " across comparisons."))
```

Of particular interest is the `Top` field, which contains the highest rank for each gene across all pairwise comparisons involving cluster `r chosen`.
The set of genes with `Top` values of 1 contains the gene with the lowest $p$-value from each comparison.
Similarly, the set of genes with `Top` values less than or equal to 10 contains the top 10 genes from each comparison.

We use the `Top` value to identify a set of genes that is guaranteed to distinguish cluster `r chosen` from any other cluster.
Figure \@ref(fig:heat-logFC) plots the log-fold changes for the top 10 genes from each pairwise comparison.

```{r heat-logFC, fig.asp = 2, fig.cap = sprintf("Heatmap of log-fold changes for the top 10 marker genes for cluster %s over all other clusters. Each column is a cluster, each row a gene. Colours are capped at -5 and 5 to preserve dynamic range.", chosen)}
best_set <- interesting[interesting$Top <= 10, ]
logFCs <- as.matrix(best_set[, -(1:3)])
colnames(logFCs) <- sub("logFC.", "", colnames(logFCs))
pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))
```

Complementing Figure \@ref(fig:heat-logFC), Figure \@ref(fig:heat-logExp) plots the log-expression values of each cells in each cluster for the top 5 genes

```{r heat-logExp, fig.wide = TRUE, fig.cap = sprintf("Heatmap of log-expression values in each sample for the top 10 marker genes in cluster %s. Each column is a sample, each row a gene. Colours are capped at -5 and 5 to preserve dynamic range.", chosen), fig.asp = 0.9}
library(scater)
.plotHeatmap(
  sce,
  features = rownames(best_set),
  columns = order(sce$cluster, sce$Treatment, sce$Sample),
  colour_columns_by = c("cluster", "Treatment", "Sample"),
  cluster_cols = FALSE, 
  center = TRUE,
  symmetric = TRUE,
  zlim = c(-5, 5),
  show_colnames = FALSE,
  main = paste0("Cluster: ", chosen),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 8)
```

**TODO:** Re-write: some inspection of Figures \@ref(fig:heat-logFC) and \@ref(fig:heat-logExp) suggest that cluster `r chosen` contains

Similar figures showing the top 10 marker genes for each cluster are available in [`output/marker_genes/union_any/heatmaps.union_any.pdf`](../output/marker_genes/union_any/heatmaps.union_any.pdf).

```{r, results = "hide"}
dev.off() # Needed to ensure next figure saves properly.
pdf(
  here(
    "output",
    "marker_genes",
    "union_any",
    "heatmaps.union_any.pdf"),
  width = 10,
  height = 12)
for (cluster in levels(sce$cluster)) {
  marker_set <- markers_union_any[[cluster]]
  best_set <- marker_set[marker_set$Top <= 10, ]
  
  .plotHeatmap(
    sce,
    features = rownames(best_set),
    columns = order(sce$cluster, sce$Treatment, sce$Sample),
    colour_columns_by = c("cluster", "Treatment", "Sample"),
    cluster_cols = FALSE, 
    center = TRUE,
    symmetric = TRUE,
    zlim = c(-5, 5),
    show_colnames = FALSE,
    main = paste0("Cluster: ", cluster),
    annotation_colors = list(
      cluster = cluster_colours,
      Treatment = treatment_colours,
      Sample = sample_colours),
    fontsize = 8)
}
dev.off()
```

We intentionally use pairwise comparisons between clusters rather than comparing each cluster to the average of all other cells.
The latter approach is sensitive to the population composition, potentially resulting in wildly different sets of markers when cell type abundances change in different contexts.
In the worst case, the presence of a single dominant subpopulation will drive the selection of top markers for every other cluster, pushing out useful genes that can resolve the various minor subpopulations.
Moreover, pairwise comparisons naturally provide more information to interpret of the utility of a marker, e.g., by providing log-fold changes to indicate which clusters are distinguished by this gene.

### Using the log-fold change

The differential expression analysis in [Standard application] considers both up- and downregulated genes to be potential markers.
However, downregulated genes are less appealing as markers as it is more difficult to interpret and experimentally validate an absence of expression.
To focus on upregulated markers, we can instead perform a one-sided $t$-test to identify genes that are upregulated in each cluster compared to the others.

```{r}
markers_union_up <- findMarkers(
  sce,
  clusters = sce$cluster,
  block = sce$Sample,
  pval.type = "any",
  direction = "up")
saveRDS(
  markers_union_up, 
  here("data", "marker_genes", "C057_Cooney.markers_union_up.rds"),
  compress = "xz")
dir.create(here("output", "marker_genes", "union_up"))
message("Writing 'union_up' marker genes to file.")
for (n in names(markers_union_up)) {
  message(n)
  gzout <- gzfile(
    description = here(
      "output", 
      "marker_genes", 
      "union_up",
      paste0("cluster_", n, ".union_up.csv.gz")),
    open = "wb")
  write.table(
    x = markers_union_up[[n]] %>%
      as.data.frame() %>%
      tibble::rownames_to_column("gene_ID"), 
    file = gzout, 
    sep = ",", 
    quote = FALSE, 
    row.names = FALSE,
    col.names = TRUE)
  close(gzout)
}
```

```{r}
interesting_up <- markers_union_up[[chosen]]
```

**TODO:** Re-write this paragraph.
For cluster `r chosen` it will not make much difference because the marker genes are mostly upregulated to begin with.
However, for other clusters this will be more useful.

The $t$-test also allows us to specify a non-zero log-fold change as the null hypothesis.
This allows us to consider the magnitude of the log-fold change in our $p$-value calculations, in a manner that is more rigorous than simply filtering directly on the log-fold changes^[Specifically, a simple threshold does not consider the variance and can enrich for genes that have both large log-fold changes and large variances [@mccarthy2009treat]]. 
For example, we can test for genes with log-fold changes that are significantly greater than 1.

```{r}
markers_union_up_lfc1 <- findMarkers(
  sce,
  clusters = sce$cluster,
  block = sce$Sample,
  pval.type = "any",
  direction = "up",
  lfc = 1)
saveRDS(
  markers_union_up_lfc1, 
  here("data", "marker_genes", "C057_Cooney.markers_union_up_lfc1.rds"),
  compress = "xz")
dir.create(here("output", "marker_genes", "union_up_lfc1"))
message("Writing 'union_up_lfc1' marker genes to file.")
for (n in names(markers_union_up_lfc1)) {
  message(n)
  gzout <- gzfile(
    description = here(
      "output", 
      "marker_genes", 
      "union_up_lfc1",
      paste0("cluster_", n, ".union_up_lfc1.csv.gz")),
    open = "wb")
  write.table(
    x = markers_union_up_lfc1[[n]] %>%
      as.data.frame() %>%
      tibble::rownames_to_column("gene_ID"), 
    file = gzout, 
    sep = ",", 
    quote = FALSE, 
    row.names = FALSE,
    col.names = TRUE)
  close(gzout)
}
```

```{r}
interesting_up_lfc1 <- markers_union_up_lfc1[[chosen]]
```

Combining these two settings yield a more focused set of candidate marker genes that are 'upregulated with a log-fold change > 1' in cluster `r chosen` (Figures \@ref(fig:heat-focused-logFC) and \@ref(fig:heat-focused-logExp)).

```{r heat-focused-logFC, fig.cap = sprintf("Heatmap of log-fold changes for cluster %s over all other clusters. Colours are capped at -5 and 5 to preserve dynamic range.", chosen)}
best_set <- interesting_up_lfc1[interesting_up_lfc1$Top <= 10,]
logFCs <- as.matrix(best_set[,-(1:3)])
colnames(logFCs) <- sub("logFC.", "", colnames(logFCs))
pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))
```

```{r heat-focused-logExp, fig.wide = TRUE, fig.cap = sprintf("Heatmap of log-expression values in each sample for the top 10 'upregulated with a log-fold change > 1' marker genes in cluster %s. Each column is a sample, each row a gene. Colours are capped at -5 and 5 to preserve dynamic range.", chosen), fig.asp = 0.9}
.plotHeatmap(
  sce,
  features = rownames(best_set),
  columns = order(sce$cluster, sce$Treatment, sce$Sample),
  colour_columns_by = c("cluster", "Treatment", "Sample"),
  cluster_cols = FALSE, 
  center = TRUE,
  symmetric = TRUE,
  zlim = c(-5, 5),
  show_colnames = FALSE,
  main = paste0("Cluster: ", chosen),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 8)
```

Similar figures showing the top 10 upregulated and 'upregulated with a log-fold change > 1' marker genes for each cluster are available in [`output/marker_genes/union_up/heatmaps.union_up.pdf`](../output/marker_genes/union_up/heatmaps.union_up.pdf). and [`output/marker_genes/union_up_lfc1/heatmaps.union_up_lfc1.pdf`](../output/marker_genes/union_up_lfc1/heatmaps.union_up_lfc1.pdf).

```{r, results = "hide"}
dev.off() # Needed to ensure next figure saves properly.
pdf(
  here(
    "output",
    "marker_genes",
    "union_up",
    "heatmaps.union_up.pdf"),
  width = 10,
  height = 12)
for (cluster in levels(sce$cluster)) {
  marker_set <- markers_union_up[[cluster]]
  best_set <- marker_set[marker_set$Top <= 10, ]
  
  .plotHeatmap(
    sce,
    features = rownames(best_set),
    columns = order(sce$cluster, sce$Treatment, sce$Sample),
    colour_columns_by = c("cluster", "Treatment", "Sample"),
    cluster_cols = FALSE, 
    center = TRUE,
    symmetric = TRUE,
    zlim = c(-5, 5),
    show_colnames = FALSE,
    main = paste0("Cluster: ", cluster),
    annotation_colors = list(
      cluster = cluster_colours,
      Treatment = treatment_colours,
      Sample = sample_colours),
    fontsize = 8)
}
dev.off()
pdf(
  here(
    "output",
    "marker_genes",
    "union_up_lfc1",
    "heatmaps.union_up_lfc1.pdf"),
  width = 10,
  height = 12)
for (cluster in levels(sce$cluster)) {
  marker_set <- markers_union_up_lfc1[[cluster]]
  best_set <- marker_set[marker_set$Top <= 10, ]
  
  .plotHeatmap(
    sce,
    features = rownames(best_set),
    columns = order(sce$cluster, sce$Treatment, sce$Sample),
    colour_columns_by = c("cluster", "Treatment", "Sample"),
    cluster_cols = FALSE, 
    center = TRUE,
    symmetric = TRUE,
    zlim = c(-5, 5),
    show_colnames = FALSE,
    main = paste0("Cluster: ", cluster),
    annotation_colors = list(
      cluster = cluster_colours,
      Treatment = treatment_colours,
      Sample = sample_colours),
    fontsize = 8)
}
dev.off()
```

Of course, this increased stringency is not without cost.
If only upregulated genes are requested, any cluster defined by downregulation of a marker gene will not contain that gene among the top set of features in its table.
This is occasionally relevant for subtypes or other states that are distinguished by high versus low expression of particular genes.
Similarly, setting an excessively high log-fold change threshold may discard otherwise useful genes.
For example, a gene upregulated in a small proportion of cells of a cluster will have a small log-fold change but can still be an effective marker if the focus is on specificity rather than sensitivity.

### Finding cluster-specific markers

The genes detected in [Standard application] and [Using the log-fold change] will give a high ranking to genes that are differentially expressed in any pairwise comparison.
This is because a gene only needs a very low $p$-value in a single pairwise comparison to achieve a low `Top` value.
A more stringent approach would only consider genes that are differentially expressed in all pairwise comparisons involving the cluster of interest.
To achieve this, we use an intersection-union test [@berger1996bioequivalence] where the combined $p$-value for each gene is the maximum of the $p$-values from all pairwise comparisons.
A gene will only achieve a low combined $p$-value if it is strongly DE in all comparisons to other clusters.

```{r}
markers_uniquely_up <- findMarkers(
  sce,
  clusters = sce$cluster,
  block = sce$Sample,
  pval.type = "all",
  direction = "up")
saveRDS(
  markers_uniquely_up, 
  here("data", "marker_genes", "C057_Cooney.markers_uniquely_up.rds"),
  compress = "xz")
dir.create(here("output", "marker_genes", "uniquely_up"))
message("Writing 'uniquely_up' marker genes to file.")
for (n in names(markers_uniquely_up)) {
  message(n)
  gzout <- gzfile(
    description = here(
      "output", 
      "marker_genes", 
      "uniquely_up",
      paste0("cluster_", n, ".uniquely_up.csv.gz")),
    open = "wb")
  write.table(
    x = markers_uniquely_up[[n]] %>%
      as.data.frame() %>%
      tibble::rownames_to_column("gene_ID"), 
    file = gzout, 
    sep = ",", 
    quote = FALSE, 
    row.names = FALSE,
    col.names = TRUE)
  close(gzout)
}
```

```{r}
interesting_uniquely_up <- markers_uniquely_up[[chosen]]
```

This strategy will only report genes that are highly specific to the cluster of interest.
When it works, it can be highly effective as it generates a small focused set of candidate markers. 
However, any gene that is expressed at the same level in two or more clusters will simply not be detected. 
This is likely to discard many interesting genes, especially if the clusters are finely resolved with weak separation.
To give a concrete example, consider a mixed population of CD4^+^-only, CD8^+^-only, double-positive and double-negative T cells.
Using this strategy, neither _Cd4_ or _Cd8_ would be detected as subpopulation-specific markers because each gene is expressed in two subpopulations.
In comparison, the strategy in [Standard application] will detect both of these genes as they will be DE between at least one pair of subpopulations.

Figures \@ref(fig:heat-focused-logFC) and \@ref(fig:heat-focused-logExp) show examples of this strategy for cluster `r chosen`.

```{r heat-uniquely-up-logFC, fig.cap = sprintf("Heatmap of log-fold changes for cluster %s over all other clusters. Colours are capped at -5 and 5 to preserve dynamic range.", chosen)}
best_set <- interesting_uniquely_up[1:20, ]
logFCs <- as.matrix(best_set[, -(1:2)])
colnames(logFCs) <- sub("logFC.", "", colnames(logFCs))
pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101))
```


```{r heat-uniquely-up-logExp, fig.wide = TRUE, fig.cap = sprintf("Heatmap of log-expression values in each sample for the top 10 uniquely upregulated marker genes in cluster %s. Each column is a sample, each row a gene. Colours are capped at -5 and 5 to preserve dynamic range.", chosen), fig.asp = 0.9}
.plotHeatmap(
  sce,
  features = rownames(best_set),
  columns = order(sce$cluster, sce$Treatment, sce$Sample),
  colour_columns_by = c("cluster", "Treatment", "Sample"),
  cluster_cols = FALSE, 
  center = TRUE,
  symmetric = TRUE,
  zlim = c(-5, 5),
  show_colnames = FALSE,
  annotation_row = data.frame(
    Sig = factor(
      ifelse(best_set[, "FDR"] < 0.05, "Yes", "No"),
      levels = c("Yes", "No")),
    row.names = rownames(best_set)),
  main = paste0("Cluster: ", chosen),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours,
    Sig = c("Yes" = "red", "No" = "lightgrey")),
  fontsize = 8)
```

Similar figures showing the top 100 uniquely upregulated marker genes for each cluster are available in [`output/marker_genes/uniquely_up/heatmaps.uniquely_up.pdf`](../output/marker_genes/uniquely_up/heatmaps.uniquely_up.pdf).
Recall that the stringency of the 'cluster-specific marker' criteria is such that a cluster may only have a small number of statistically significant marker genes or indeed none at all.
Therefore, these plots include an row annotation highlighting if the gene is a statisticially significant cluster-specific marker (i.e. $FDR < 0.05$).


```{r, results = "hide"}
dev.off() # Needed to ensure next figure saves properly.
pdf(
  here(
    "output",
    "marker_genes",
    "uniquely_up",
    "heatmaps.uniquely_up.pdf"),
  width = 10,
  height = 12)
for (cluster in levels(sce$cluster)) {
  marker_set <- markers_uniquely_up[[cluster]]
  best_set <- marker_set[1:100, ]
  
  .plotHeatmap(
    sce,
    features = rownames(best_set),
    columns = order(sce$cluster, sce$Treatment, sce$Sample),
    colour_columns_by = c("cluster", "Treatment", "Sample"),
    cluster_cols = FALSE, 
    center = TRUE,
    symmetric = TRUE,
    zlim = c(-5, 5),
    show_colnames = FALSE,
    annotation_row = data.frame(
      Sig = factor(
        ifelse(best_set[, "FDR"] < 0.05, "Yes", "No"),
        levels = c("Yes", "No")),
      row.names = rownames(best_set)),
    main = paste0("Cluster: ", cluster),
    annotation_colors = list(
      cluster = cluster_colours,
      Treatment = treatment_colours,
      Sample = sample_colours,
      Sig = c("Yes" = "red", "No" = "lightgrey")),
    fontsize = 8)
}
dev.off()
```

## Summary

The tables of marker genes are available as CSV files in [`output/marker_genes`] and are named as follows:

- `union_any`: Marker genes from [Standard application] whereby marker genes are formed from the **union** of genes differentially expressed in **any** direction.
- `union_up`: Marker genes from [Using the log-fold change] whereby marker genes are formed from the **union** of genes differentially expressed that are **up**regulated.
- `union_up_lfc1`: Marker genes from [Using the log-fold change] whereby marker genes are formed from the **union** of genes differentially expressed that are **up**regulated with a log-fold change of at least 1 (**lfc1**).
- `uniquely_up`: Marker genes from [Finding cluster-specific markers] whereby marker genes are cluster-specific (**uniquely**) differentially expressed genes that are **up**regulated.

# Using marker genes to perform cell type annotation

Regardless of the strategy employed, [Standard application], [Using the log-fold change] or [Finding cluster-speicific markers], the result is a gene list that needs to be examined to try to identify the cell type.
As such, they can be analysed like any other gene list, just as you might a list of differentially expressed genes from a bulk RNA-seq experiment.
This includes:
- Staring at heatmaps and spreadsheets, such as those included with this report, and googling some of the more informative genes, such as the cluster-specific marker genes.
- Gene set enrichment analysis, e.g., using GO or KEGG terms.
This can require a fair amount of manual work and knowledge of the biological system.
In the next section, we will complement this rather tedious but necessary manual work with an automated approach to cell type labelling.

# Automated cell type labelling with `r Biocpkg("SingleR")`

```{r}
library(SingleR)
```

`r Biocpkg("SingleR")` is an automatic annotation method for scRNAseq data [@aran2019reference].
Given a reference data set of samples^[This can be individual cells or bulk samples.] with known labels, it labels new cells from a test data set based on similarity to the reference set.
Specifically, for each test cell:
1. We compute the Spearman correlation between its expression profile and that of each reference sample. 
2. We define the per-label score as a fixed quantile (by default, 0.8) of the distribution of correlations.
3. We repeat this for all labels and we take the label with the highest score as the annotation for this cell.
4. Fianlly, we perform a fine-tuning step:
- The reference data set is subsetted to only include labels with scores close to the maximum.
- Scores are recomputed using only marker genes for the subset of labels.
- This is iterated until one label remains.
For visualization purposes we use the normalized scores, which are the scores linearly adjusted for each cell so that the smallest score is 0 and the largest score is 1.
This is followed by cubing of the adjusted scores to improve dynamic range near 1. 
Automatic annotation provides a convenient way of transferring biological knowledge across data sets.
In this manner, the burden of interpreting clusters and defining marker genes only has to be done once (i.e. for the reference set).
I use `r Biocpkg("SingleR")` to annotate the data set against 2 reference data sets:
**TODO:** Describe reference data sets.

`r Biocpkg("SingleR")` can be used to annotate at the cell-level or the cluster-level.
The latter is generally used to speed-up calculations, which is not necessary for this sized data set.

Therefore, I have annotated at the cell-level to obtain a higher resolution analysis.

## `HumanPrimaryCellAtlasData`

```{r}
hpcad <- HumanPrimaryCellAtlasData()
```
The `HumanPrimaryCellAtlasData` reference set entails 830 microarray samples generated by ImmGen from pure populations of murine immune cells [@ImmGenRef] ([http://www.hpcad.org/](http://www.hpcad.org/)) and processed and normalized as described in [@aran2019reference].
Each sample has a 'main' and a 'fine' cell type label, summarised below.

**TODO:** Describe putatively relevant cell types in reference set.

```{r}
.adf(colData(hpcad)) %>%
  tabyl(label.main) %>%
  adorn_pct_formatting(1) %>%
  knitr::kable(
    caption = "Summary of main cell types in the `HumanPrimaryCellAtlasData` reference set.")
```

```{r}
paged_table(
  .adf(colData(hpcad)) %>% 
    dplyr::count(label.main, label.fine) %>%
    dplyr::arrange(label.main))
```

### Main label

```{r}
pred_hpcad_cell_main <- SingleR(
  test = sce,
  ref = hpcad, 
  labels = hpcad$label.main,
  BPPARAM = SerialParam())
```

Annotating against the main labels, we obtain the following cell type labels.

```{r}
tabyl(data.frame(label.main = pred_hpcad_cell_main$labels), label.main) %>%
  adorn_pct_formatting(digits = 1) %>%  
  dplyr::arrange(desc(n)) %>%
  knitr::kable(
    caption = "Cell label assignments using the main labels of the `HumanPrimaryCellAtlasData` reference data.")
```

Heatmaps of the normalized scores are shown, with and without clustering by these normalized scores, in Figures \@ref(fig:heat-hpcad-main-clustered) and \@ref(fig:heat-hpcad-main).

```{r heat-hpcad-main-clustered, fig.cap = "Heatmap of normalized scores using the main labels from the `HumanPrimaryCellAtlasData` reference set. Cells are columns, rows are labels. Columns are ordered by clustering the normalized scores.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_hpcad_cell_main), colnames(sce)))
plotScoreHeatmap(
  pred_hpcad_cell_main,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_hpcad_cell_main)),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

```{r heat-hpcad-main, fig.cap = "Heatmap of normalized scores using the main labels from the `HumanPrimaryCellAtlasData` reference set. Cells are columns, rows are labels. Columns are ordered by and annotated by the column labels.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_hpcad_cell_main), colnames(sce)))
plotScoreHeatmap(
  pred_hpcad_cell_main,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_hpcad_cell_main)),
  order.by.clusters = TRUE,
  clusters = sce$cluster,
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

Figure \@ref(fig:tsne-hpcad-main) overlays the normalized scores for the 10 labels with the largest maximum scores on the t-SNE plot.

```{r tsne-hpcad-main, fig.cap = "t-SNE overlaid with normalized scores using the main labels from the `HumanPrimaryCellAtlasData` reference set. Only the 10 labels with the largest maximum scores are shown.", fig.asp = 2}
plotScoreReducedDim(
  pred_hpcad_cell_main, 
  sce,
  max.labels = 10,
  ncol = 2,
  use_dimred = "TSNE")
```

### Fine label

```{r}
pred_hpcad_cell_fine <- SingleR(
  test = sce,
  ref = hpcad, 
  labels = hpcad$label.fine,
  BPPARAM = SerialParam())
```

Annotating against the fine labels, we obtain the following cell type labels.

```{r}
tabyl(data.frame(label.fine = pred_hpcad_cell_fine$labels), label.fine) %>%
  adorn_pct_formatting(digits = 1) %>%  
  dplyr::arrange(desc(n)) %>%
  knitr::kable(
    caption = "Cell label assignments using the fine labels of the `HumanPrimaryCellAtlasData` reference data.")
```

Heatmaps of the normalized scores are shown, with and without clustering by these normalized scores, in Figures \@ref(fig:heat-hpcad-fine-clustered) and \@ref(fig:heat-hpcad-fine).

```{r heat-hpcad-fine-clustered, fig.cap = "Heatmap of normalized scores using the fine labels from the `HumanPrimaryCellAtlasData` reference set. Cells are columns, rows are labels. Columns are ordered by clustering the normalized scores.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_hpcad_cell_fine), colnames(sce)))
plotScoreHeatmap(
  pred_hpcad_cell_fine,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_hpcad_cell_fine)),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

```{r heat-hpcad-fine, fig.cap = "Heatmap of normalized scores using the fine labels from the `HumanPrimaryCellAtlasData` reference set. Cells are columns, rows are labels. Columns are ordered by and annotated by the column labels.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_hpcad_cell_fine), colnames(sce)))
plotScoreHeatmap(
  pred_hpcad_cell_fine,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_hpcad_cell_fine)),
  order.by.clusters = TRUE,
  clusters = sce$cluster,
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

Figure \@ref(fig:tsne-hpcad-fine) overlays the normalized scores for the 10 labels with the largest maximum scores on the t-SNE plot.

```{r tsne-hpcad-fine, fig.cap = "t-SNE overlaid with normalized scores using the fine labels from the `HumanPrimaryCellAtlasData` reference set. Only the 10 labels with the largest maximum scores are shown.", fig.asp = 2}
plotScoreReducedDim(
  pred_hpcad_cell_main, 
  sce,
  max.labels = 10,
  ncol = 2,
  use_dimred = "TSNE")
```

## `BlueprintEncodeData`

```{r}
bed <- BlueprintEncodeData()
```
The `BlueprintEncodeData` reference set entails 830 microarray samples generated by ImmGen from pure populations of murine immune cells [@ImmGenRef] ([http://www.bed.org/](http://www.bed.org/)) and processed and normalized as described in [@aran2019reference].
Each sample has a 'main' and a 'fine' cell type label, summarised below.

**TODO:** Describe putatively relevant cell types in reference set.

```{r}
.adf(colData(bed)) %>%
  tabyl(label.main) %>%
  adorn_pct_formatting(1) %>%
  knitr::kable(
    caption = "Summary of main cell types in the `BlueprintEncodeData` reference set.")
```

```{r}
paged_table(
  .adf(colData(bed)) %>% 
    dplyr::count(label.main, label.fine) %>%
    dplyr::arrange(label.main))
```

### Main label

```{r}
pred_bed_cell_main <- SingleR(
  test = sce,
  ref = bed, 
  labels = bed$label.main,
  BPPARAM = SerialParam())
```

Annotating against the main labels, we obtain the following cell type labels.

```{r}
tabyl(data.frame(label.main = pred_bed_cell_main$labels), label.main) %>%
  adorn_pct_formatting(digits = 1) %>%  
  dplyr::arrange(desc(n)) %>%
  knitr::kable(
    caption = "Cell label assignments using the main labels of the `BlueprintEncodeData` reference data.")
```

Heatmaps of the normalized scores are shown, with and without clustering by these normalized scores, in Figures \@ref(fig:heat-bed-main-clustered) and \@ref(fig:heat-bed-main).

```{r heat-bed-main-clustered, fig.cap = "Heatmap of normalized scores using the main labels from the `bedRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by clustering the normalized scores.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_bed_cell_main), colnames(sce)))
plotScoreHeatmap(
  pred_bed_cell_main,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_bed_cell_main)),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

```{r heat-bed-main, fig.cap = "Heatmap of normalized scores using the main labels from the `bedRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by and annotated by the column labels.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_bed_cell_main), colnames(sce)))
plotScoreHeatmap(
  pred_hpcad_cell_main,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_bed_cell_main)),
  order.by.clusters = TRUE,
  clusters = sce$cluster,
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

Figure \@ref(fig:tsne-bed-main) overlays the normalized scores for the 10 labels with the largest maximum scores on the t-SNE plot.

```{r tsne-bed-main, fig.cap = "t-SNE overlaid with normalized scores using the main labels from the `BlueprintEncodeData` reference set. Only the 10 labels with the largest maximum scores are shown.", fig.asp = 2}
plotScoreReducedDim(
  pred_bed_cell_main, 
  sce,
  max.labels = 10,
  ncol = 2,
  use_dimred = "TSNE")
```

### Fine label

```{r}
pred_bed_cell_fine <- SingleR(
  test = sce,
  ref = bed, 
  labels = bed$label.fine,
  BPPARAM = SerialParam())
```

Annotating against the fine labels, we obtain the following cell type labels.

```{r}
tabyl(data.frame(label.fine = pred_bed_cell_fine$labels), label.fine) %>%
  adorn_pct_formatting(digits = 1) %>%  
  dplyr::arrange(desc(n)) %>%
  knitr::kable(
    caption = "Cell label assignments using the fine labels of the `BlueprintEncodeData` reference data.")
```

Heatmaps of the normalized scores are shown, with and without clustering by these normalized scores, in Figures \@ref(fig:heat-bed-fine-clustered) and \@ref(fig:heat-bed-fine).

```{r heat-bed-fine-clustered, fig.cap = "Heatmap of normalized scores using the fine labels from the `bedRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by clustering the normalized scores.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_bed_cell_fine), colnames(sce)))
plotScoreHeatmap(
  pred_bed_cell_fine,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_bed_cell_fine)),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

```{r heat-bed-fine, fig.cap = "Heatmap of normalized scores using the fine labels from the `bedRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by and annotated by the column labels.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_bed_cell_fine), colnames(sce)))
plotScoreHeatmap(
  pred_bed_cell_fine,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_bed_cell_fine)),
  order.by.clusters = TRUE,
  clusters = sce$cluster,
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

Figure \@ref(fig:tsne-bed-fine) overlays the normalized scores for the 10 labels with the largest maximum scores on the t-SNE plot.

```{r tsne-bed-fine, fig.cap = "t-SNE overlaid with normalized scores using the fine labels from the `BlueprintEncodeData` reference set. Only the 10 labels with the largest maximum scores are shown.", fig.asp = 2}
plotScoreReducedDim(
  pred_bed_cell_fine, 
  sce,
  max.labels = 10,
  ncol = 2,
  use_dimred = "TSNE")
```

## `DatabaseImmuneCellExpressionData`

```{r}
diced <- DatabaseImmuneCellExpressionData()
```
The `DatabaseImmuneCellExpressionData` reference set entails 830 microarray samples generated by ImmGen from pure populations of murine immune cells [@ImmGenRef] ([http://www.diced.org/](http://www.diced.org/)) and processed and normalized as described in [@aran2019reference].
Each sample has a 'main' and a 'fine' cell type label, summarised below.

**TODO:** Describe putatively relevant cell types in reference set.

```{r}
.adf(colData(diced)) %>%
  tabyl(label.main) %>%
  adorn_pct_formatting(1) %>%
  knitr::kable(
    caption = "Summary of main cell types in the `DatabaseImmuneCellExpressionData` reference set.")
```

```{r}
paged_table(
  .adf(colData(diced)) %>% 
    dplyr::count(label.main, label.fine) %>%
    dplyr::arrange(label.main))
```

### Main label

```{r}
pred_diced_cell_main <- SingleR(
  test = sce,
  ref = diced, 
  labels = diced$label.main,
  BPPARAM = SerialParam())
```

Annotating against the main labels, we obtain the following cell type labels.

```{r}
tabyl(data.frame(label.main = pred_diced_cell_main$labels), label.main) %>%
  adorn_pct_formatting(digits = 1) %>%  
  dplyr::arrange(desc(n)) %>%
  knitr::kable(
    caption = "Cell label assignments using the main labels of the `DatabaseImmuneCellExpressionData` reference data.")
```

Heatmaps of the normalized scores are shown, with and without clustering by these normalized scores, in Figures \@ref(fig:heat-diced-main-clustered) and \@ref(fig:heat-diced-main).

```{r heat-diced-main-clustered, fig.cap = "Heatmap of normalized scores using the main labels from the `dicedRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by clustering the normalized scores.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_diced_cell_main), colnames(sce)))
plotScoreHeatmap(
  pred_diced_cell_main,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_diced_cell_main)),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

```{r heat-diced-main, fig.cap = "Heatmap of normalized scores using the main labels from the `dicedRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by and annotated by the column labels.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_diced_cell_main), colnames(sce)))
plotScoreHeatmap(
  pred_diced_cell_main,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_diced_cell_main)),
  order.by.clusters = TRUE,
  clusters = sce$cluster,
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

Figure \@ref(fig:tsne-diced-main) overlays the normalized scores for the 10 labels with the largest maximum scores on the t-SNE plot.

```{r tsne-diced-main, fig.cap = "t-SNE overlaid with normalized scores using the main labels from the `DatabaseImmuneCellExpressionData` reference set. Only the 10 labels with the largest maximum scores are shown.", fig.asp = 2}
plotScoreReducedDim(
  pred_diced_cell_main, 
  sce,
  max.labels = 10,
  ncol = 2,
  use_dimred = "TSNE")
```

### Fine label

```{r}
# TODO: This blows up memory usage, so may need to run this on server (or just 
#       quit Chrome and Slack ...).
pred_diced_cell_fine <- SingleR(
  test = sce,
  ref = diced, 
  labels = diced$label.fine,
  BPPARAM = SerialParam())
```

Annotating against the fine labels, we obtain the following cell type labels.

```{r}
tabyl(data.frame(label.fine = pred_diced_cell_fine$labels), label.fine) %>%
  adorn_pct_formatting(digits = 1) %>%  
  dplyr::arrange(desc(n)) %>%
  knitr::kable(
    caption = "Cell label assignments using the fine labels of the `DatabaseImmuneCellExpressionData` reference data.")
```

Heatmaps of the normalized scores are shown, with and without clustering by these normalized scores, in Figures \@ref(fig:heat-diced-fine-clustered) and \@ref(fig:heat-diced-fine).

```{r heat-diced-fine-clustered, fig.cap = "Heatmap of normalized scores using the fine labels from the `dicedRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by clustering the normalized scores.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_diced_cell_fine), colnames(sce)))
plotScoreHeatmap(
  pred_diced_cell_fine,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_diced_cell_fine)),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

```{r heat-diced-fine, fig.cap = "Heatmap of normalized scores using the fine labels from the `dicedRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by and annotated by the column labels.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_diced_cell_fine), colnames(sce)))
plotScoreHeatmap(
  pred_diced_cell_fine,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_diced_cell_fine)),
  order.by.clusters = TRUE,
  clusters = sce$cluster,
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

Figure \@ref(fig:tsne-diced-fine) overlays the normalized scores for the 10 labels with the largest maximum scores on the t-SNE plot.

```{r tsne-diced-fine, fig.cap = "t-SNE overlaid with normalized scores using the fine labels from the `DatabaseImmuneCellExpressionData` reference set. Only the 10 labels with the largest maximum scores are shown.", fig.asp = 2}
plotScoreReducedDim(
  pred_diced_cell_fine, 
  sce,
  max.labels = 10,
  ncol = 2,
  use_dimred = "TSNE")
```

## `MonacoImmuneData`

```{r}
mid <- MonacoImmuneData()
```
The `MonacoImmuneData` reference set entails 830 microarray samples generated by ImmGen from pure populations of murine immune cells [@ImmGenRef] ([http://www.mid.org/](http://www.mid.org/)) and processed and normalized as described in [@aran2019reference].
Each sample has a 'main' and a 'fine' cell type label, summarised below.

**TODO:** Describe putatively relevant cell types in reference set.

```{r}
.adf(colData(mid)) %>%
  tabyl(label.main) %>%
  adorn_pct_formatting(1) %>%
  knitr::kable(
    caption = "Summary of main cell types in the `MonacoImmuneData` reference set.")
```

```{r}
paged_table(
  .adf(colData(mid)) %>% 
    dplyr::count(label.main, label.fine) %>%
    dplyr::arrange(label.main))
```

### Main label

```{r}
pred_mid_cell_main <- SingleR(
  test = sce,
  ref = mid, 
  labels = mid$label.main,
  BPPARAM = SerialParam())
```

Annotating against the main labels, we obtain the following cell type labels.

```{r}
tabyl(data.frame(label.main = pred_mid_cell_main$labels), label.main) %>%
  adorn_pct_formatting(digits = 1) %>%  
  dplyr::arrange(desc(n)) %>%
  knitr::kable(
    caption = "Cell label assignments using the main labels of the `MonacoImmuneData` reference data.")
```

Heatmaps of the normalized scores are shown, with and without clustering by these normalized scores, in Figures \@ref(fig:heat-mid-main-clustered) and \@ref(fig:heat-mid-main).

```{r heat-mid-main-clustered, fig.cap = "Heatmap of normalized scores using the main labels from the `midRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by clustering the normalized scores.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_mid_cell_main), colnames(sce)))
plotScoreHeatmap(
  pred_mid_cell_main,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_mid_cell_main)),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

```{r heat-mid-main, fig.cap = "Heatmap of normalized scores using the main labels from the `midRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by and annotated by the column labels.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_mid_cell_main), colnames(sce)))
plotScoreHeatmap(
  pred_diced_cell_main,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_mid_cell_main)),
  order.by.clusters = TRUE,
  clusters = sce$cluster,
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

Figure \@ref(fig:tsne-mid-main) overlays the normalized scores for the 10 labels with the largest maximum scores on the t-SNE plot.

```{r tsne-mid-main, fig.cap = "t-SNE overlaid with normalized scores using the main labels from the `MonacoImmuneData` reference set. Only the 10 labels with the largest maximum scores are shown.", fig.asp = 2}
plotScoreReducedDim(
  pred_diced_cell_main, 
  sce,
  max.labels = 10,
  ncol = 2,
  use_dimred = "TSNE")
```

### Fine label

```{r}
pred_mid_cell_fine <- SingleR(
  test = sce,
  ref = mid, 
  labels = mid$label.fine,
  BPPARAM = SerialParam())
```

Annotating against the fine labels, we obtain the following cell type labels.

```{r}
tabyl(data.frame(label.fine = pred_mid_cell_fine$labels), label.fine) %>%
  adorn_pct_formatting(digits = 1) %>%  
  dplyr::arrange(desc(n)) %>%
  knitr::kable(
    caption = "Cell label assignments using the fine labels of the `MonacoImmuneData` reference data.")
```

Heatmaps of the normalized scores are shown, with and without clustering by these normalized scores, in Figures \@ref(fig:heat-mid-fine-clustered) and \@ref(fig:heat-mid-fine).

```{r heat-mid-fine-clustered, fig.cap = "Heatmap of normalized scores using the fine labels from the `midRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by clustering the normalized scores.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_mid_cell_fine), colnames(sce)))
plotScoreHeatmap(
  pred_mid_cell_fine,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_mid_cell_fine)),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

```{r heat-mid-fine, fig.cap = "Heatmap of normalized scores using the fine labels from the `midRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by and annotated by the column labels.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_mid_cell_fine), colnames(sce)))
plotScoreHeatmap(
  pred_diced_cell_fine,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_mid_cell_fine)),
  order.by.clusters = TRUE,
  clusters = sce$cluster,
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

Figure \@ref(fig:tsne-mid-fine) overlays the normalized scores for the 10 labels with the largest maximum scores on the t-SNE plot.

```{r tsne-mid-fine, fig.cap = "t-SNE overlaid with normalized scores using the fine labels from the `MonacoImmuneData` reference set. Only the 10 labels with the largest maximum scores are shown.", fig.asp = 2}
plotScoreReducedDim(
  pred_diced_cell_fine, 
  sce,
  max.labels = 10,
  ncol = 2,
  use_dimred = "TSNE")
```

## `NovershternHematopoieticData`

```{r}
nhd <- NovershternHematopoieticData()
```
The `NovershternHematopoieticData` reference set entails 830 microarray samples generated by ImmGen from pure populations of murine immune cells [@ImmGenRef] ([http://www.nhd.org/](http://www.nhd.org/)) and processed and normalized as described in [@aran2019reference].
Each sample has a 'main' and a 'fine' cell type label, summarised below.

**TODO:** Describe putatively relevant cell types in reference set.

```{r}
.adf(colData(nhd)) %>%
  tabyl(label.main) %>%
  adorn_pct_formatting(1) %>%
  knitr::kable(
    caption = "Summary of main cell types in the `NovershternHematopoieticData` reference set.")
```

```{r}
paged_table(
  .adf(colData(nhd)) %>% 
    dplyr::count(label.main, label.fine) %>%
    dplyr::arrange(label.main))
```

### Main label

```{r}
pred_nhd_cell_main <- SingleR(
  test = sce,
  ref = nhd, 
  labels = nhd$label.main,
  BPPARAM = SerialParam())
```

Annotating against the main labels, we obtain the following cell type labels.

```{r}
tabyl(data.frame(label.main = pred_nhd_cell_main$labels), label.main) %>%
  adorn_pct_formatting(digits = 1) %>%  
  dplyr::arrange(desc(n)) %>%
  knitr::kable(
    caption = "Cell label assignments using the main labels of the `NovershternHematopoieticData` reference data.")
```

Heatmaps of the normalized scores are shown, with and without clustering by these normalized scores, in Figures \@ref(fig:heat-nhd-main-clustered) and \@ref(fig:heat-nhd-main).

```{r heat-nhd-main-clustered, fig.cap = "Heatmap of normalized scores using the main labels from the `nhdRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by clustering the normalized scores.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_nhd_cell_main), colnames(sce)))
plotScoreHeatmap(
  pred_nhd_cell_main,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_mid_cell_main)),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

```{r heat-nhd-main, fig.cap = "Heatmap of normalized scores using the main labels from the `nhdRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by and annotated by the column labels.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_mid_cell_main), colnames(sce)))
plotScoreHeatmap(
  pred_diced_cell_main,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_mid_cell_main)),
  order.by.clusters = TRUE,
  clusters = sce$cluster,
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

Figure \@ref(fig:tsne-nhd-main) overlays the normalized scores for the 10 labels with the largest maximum scores on the t-SNE plot.

```{r tsne-nhd-main, fig.cap = "t-SNE overlaid with normalized scores using the main labels from the `NovershternHematopoieticData` reference set. Only the 10 labels with the largest maximum scores are shown.", fig.asp = 2}
plotScoreReducedDim(
  pred_nhd_cell_main, 
  sce,
  max.labels = 10,
  ncol = 2,
  use_dimred = "TSNE")
```

### FIne label

```{r}
pred_nhd_cell_fine <- SingleR(
  test = sce,
  ref = nhd, 
  labels = nhd$label.fine,
  BPPARAM = SerialParam())
```

Annotating against the fine labels, we obtain the following cell type labels.

```{r}
tabyl(data.frame(label.fine = pred_nhd_cell_fine$labels), label.fine) %>%
  adorn_pct_formatting(digits = 1) %>%  
  dplyr::arrange(desc(n)) %>%
  knitr::kable(
    caption = "Cell label assignments using the fine labels of the `NovershternHematopoieticData` reference data.")
```

Heatmaps of the normalized scores are shown, with and without clustering by these normalized scores, in Figures \@ref(fig:heat-nhd-fine-clustered) and \@ref(fig:heat-nhd-fine).

```{r heat-nhd-fine-clustered, fig.cap = "Heatmap of normalized scores using the fine labels from the `nhdRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by clustering the normalized scores.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_nhd_cell_fine), colnames(sce)))
plotScoreHeatmap(
  pred_nhd_cell_fine,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_mid_cell_fine)),
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

```{r heat-nhd-fine, fig.cap = "Heatmap of normalized scores using the fine labels from the `nhdRNAseqData` reference set. Cells are columns, rows are labels. Columns are ordered by and annotated by the column labels.", fig.asp = 0.9, layout = "l-body-outset"}
stopifnot(identical(rownames(pred_mid_cell_fine), colnames(sce)))
plotScoreHeatmap(
  pred_diced_cell_fine,
  annotation_col = data.frame(
    cluster = sce$cluster, 
    Treatment = sce$Treatment, 
    Sample = sce$Sample,
    row.names = rownames(pred_mid_cell_fine)),
  order.by.clusters = TRUE,
  clusters = sce$cluster,
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours,
    Sample = sample_colours),
  fontsize = 6)
```

Figure \@ref(fig:tsne-nhd-fine) overlays the normalized scores for the 10 labels with the largest maximum scores on the t-SNE plot.

```{r tsne-nhd-fine, fig.cap = "t-SNE overlaid with normalized scores using the fine labels from the `NovershternHematopoieticData` reference set. Only the 10 labels with the largest maximum scores are shown.", fig.asp = 2}
plotScoreReducedDim(
  pred_nhd_cell_fine, 
  sce,
  max.labels = 10,
  ncol = 2,
  use_dimred = "TSNE")
```

## Summary

Any automated cell type annotation method is only as good as its reference set.
A few points on each reference set with respect to the test data set bear repeating:

**TODO:** Re-write these points

- The `ImmGenData` includes multiple types of haematopoietic stem cells but does not include any cells from the erythroid lineage.
- The `HaemopediaMouseRNAseqData` includes multiple types of haematopoietic progenitor cells, although not stem cells *per se*, and includes cells from the erythroid lineage.

Any cell type present in the test set but with no good match in the reference set will be misannotated to some degree.
We will need to consider the cell types available in each reference set and the appropriateness of annotating embroyonic cells using reference sets that likely mostly comprise adult cells.

**This means that you will need to assess the appropriateness of the reference sets for your data set.**

# Cell cycle assignment

On occasion, it can be desirable to determine cell cycle activity from scRNA-seq data.
In and of itself, the distribution of cells across phases of the cell cycle is not usually informative, but we can use this to determine if there are differences in cell cycle progression between subpopulations or across treatment conditions.
Many of the key events in the cell cycle (e.g., passage through checkpoints) are post-translational and thus not directly visible in transcriptomic data; nonetheless, there are enough changes in expression that can be exploited to determine cell cycle phase.

## Using the cyclins

```{r, results = "hide"}
cyclin_genes <- grep("^CCN[ABDE][0-9]$", rowData(sce)$Symbol)
cyclin_genes <- rownames(sce)[cyclin_genes]
cyclin_genes
```

The cyclins control progression through the cell cycle and have well-characterized patterns of expression across cell cycle phases.
Cyclin D is expressed throughout but peaks at G1; cyclin E is expressed highest in the G1/S transition; cyclin A is expressed across S and G2; and cyclin B is expressed highest in late G2 and mitosis.
Inspection of the relative expression of cyclins across the population can often be sufficient to determine the relative cell cycle activity in each cluster.

**TODO:** Re-write

For example, Figure \@ref(fig:cyclin-heatmap) shows that cluster 1 is likely to be in G2/M phase while the other clusters are scattered across the later phases.

```{r cyclin-heatmap, fig.cap = "Heatmap of the log-normalized expression values of the cyclin genes in the dataset."}
plotHeatmap(
  sce,
  colour_columns_by = "cluster",
  cluster_cols = FALSE, 
  columns = order(sce$cluster),
  cluster_rows = FALSE, 
  features = sort(cyclin_genes),
  show_colnames = FALSE)
```

We can also use standard differential expression methods to look for upregulation of each cyclin, allowing us to determine if there are more cells in the corresponding phase of the cell cycle between subpopulations.

```{r}
fit <- pairwiseWilcox(
  x = logcounts(sce), 
  clusters = sce$cluster,
  block = sce$Sample,
  direction = "up",
  log.p = TRUE,
  subset.row = cyclin_genes)
markers <- combineMarkers(
  fit$statistics,
  fit$pairs,
  pval.type = "any",
  log.p.in = TRUE,
  log.p.out = FALSE,
  full.stats = FALSE,
  pval.field = "log.p.value",
  effect.field = "overlap")
```

Here we use pairwise Wilcoxon rank sum tests to compute differential expression of cycline genes between each pair of clusters.
The Wilcoxon test estimates effect sizes as overlap proportions (`overlap` in the tables below).
Theoverlap proportion is defined as the probability that a randomly selected cell in $A$ has a greater expression value of $X$ than a randomly selected cell in $B$.
Overlap proportions near 0 ($A$ is lower than $B$) or 1 ($A$ is higher than $B$) indicate that the expression distributions are well-separated.
The Wilcoxon rank sum test effectively tests for significant deviations from an overlap proportion of 0.5.

**TODO:** Re-write and re-do tables.

We can infer that cluster 1 has more cells in G2/M than the other clusters, based on higher expression of the cyclin B's.

```{r}
knitr::kable(
  .adf(markers[[1]]),
  caption = "Cyclin DE analysis comparing cluster 1 to clusters 2 and 3.")
```

```{r}
knitr::kable(
  .adf(markers[[2]]),
  caption = "Cyclin DE analysis comparing cluster 2 to clusters 1 and 3.")
```

```{r}
knitr::kable(
  .adf(markers[[3]]),
  caption = "Cyclin DE analysis comparing cluster 3 to clusters 1 and 2.")
```

Direct examination of cyclin expression is easily understood, interpreted and validated with other technologies.
However, it is best suited for statements about relative cell cycle activity; for example, we would find it difficult to assign cell cycle phase in Figure \@ref(fig:cyclin-heatmap) without the presence of clusters spanning all phases to provide benchmarks for "high" and "low" expression of each cyclin.
We also assume that cyclin expression is not affected by biological processes other than the cell cycle, which may be a strong assumption in some cases, e.g., malignant cells.

```{r}
# NOTE: Haven't done 'Using reference profiles'-type analysis because the 
#       example dataset in OSCA is from mouse, and I haven't gone looking for 
#       a human equivalent.
```

## Using the `cyclone()` classifier

The prediction method described by [@scialdone2015computational] is another approach for classifying cells into cell cycle phases.
Using a reference dataset, we first compute the sign of the difference in expression between each pair of genes.
Pairs with changes in the sign across cell cycle phases are chosen as markers.
Cells in a test dataset can then be classified into the appropriate phase, based on whether the observed sign for each marker pair is consistent with one phase or another. 
This approach is implemented in the `cyclone()` function from the `R BiocStyle::Biocpkg("scran")` package.

```{r}
hs_pairs <- readRDS(
  system.file("exdata", "human_cycle_markers.rds", package = "scran"))
# Using Ensembl IDs to match up with the annotation in 'mm.pairs'.
# TODO: This takes ages, so perhaps run on server.
set.seed(100)
assignments <- cyclone(sce, hs_pairs, gene.names = rowData(sce)$ID)
```

The phase assignment result for each cell in the dataset is shown in Figure \@ref(fig:cyclone). 

```{r cyclone, fig.cap = "Cell cycle phase scores from applying the pair-based classifier on the dataset. Each point represents a cell, plotted according to its scores for G1 and G2/M phases, and coloured according to cluster.", fig.asp = 0.5}
plot(
  x = assignments$score$G1, 
  y = assignments$score$G2M,
  xlab = "G1 score",
  ylab = "G2/M score",
  pch = 16,
  col = cluster_colours[sce$cluster])
legend(
  "topright",
  pch = 16,
  col = cluster_colours,
  legend = names(cluster_colours),
  title = "Cluster")
```

# TODOs

- [ ] Cell cycle (see C011)
