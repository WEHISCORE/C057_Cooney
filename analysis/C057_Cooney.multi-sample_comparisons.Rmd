---
title: "Multi-sample comparisons with the Cooney (C057) memory CD4+ T-cell data set"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: Single Cell Open Research Endeavour (SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: radix::radix_article
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(here)
library(janitor)
library(BiocStyle)
library(BiocParallel)
source(here("analysis", "helper_functions.R"))
# NOTE: Using multiple cores siezes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 1L, 9L))
register(MulticoreParam(workers = getOption("mc.cores")))
knitr::opts_chunk$set(
  fig.path = "C057_Cooney_multi-sample_comparisons_files/")
```

# Introduction

Differential analyses of multi-condition scRNA-seq experiments can be broadly split into two categories: differential expression (DE) and differential abundance (DA) analyses.
The former tests for changes in expression between conditions for cells of the same type that are present in both conditions, while the latter tests for changes in the composition of cell types (or states, etc.) between conditions.

The aim of this study is to identify differentially expressed genes between infected and uninfected samples.

```{r}
library(SingleCellExperiment)
library(dplyr)
library(scater)
library(edgeR)

sce <- readRDS(here("data", "SCEs", "C057_Cooney.annotated.SCE.rds"))

dir.create(here("output",))
```

```{r}
hto_to_sample_df <- as.data.frame(colData(sce)) %>%
  dplyr::select(hto_cluster, HTO, Sample, Treatment, Replicate) %>%
  dplyr::distinct()

# Some useful colours
hto_cluster_colours <- setNames(
  colorblindr::palette_OkabeIto,
  levels(sce$hto_cluster))
hto_cluster_colours <- hto_cluster_colours[!is.na(names(hto_cluster_colours))]
hto_colours <- hto_cluster_colours
names(hto_colours) <- dplyr::inner_join(
  data.frame(hto_cluster = names(hto_cluster_colours)),
  hto_to_sample_df) %>%
  dplyr::pull(HTO)
sample_colours <- hto_cluster_colours
names(sample_colours) <- dplyr::inner_join(
  data.frame(hto_cluster = names(sample_colours)),
  hto_to_sample_df) %>%
  dplyr::pull(Sample)
treatment_colours <- c(
  "Infected" = "#e41a1c",
  "Uninfected" = "#377eb8",
  "Unknown" = "grey70")
# NOTE: No replicate_colours because we won't ever colour by this.
cluster_colours <- setNames(
  Polychrome::dark.colors(nlevels(sce$cluster)),
  levels(sce$cluster))
```

We discard the 'Unknown' samples as these cannot be used for differential analyses.

```{r}
sce <- sce[, sce$Sample != "Unknown"]
# NOTE: Update the factor columns.
colData(sce) <- DataFrame(
  lapply(colData(sce), function(x) {
    if (is.factor(x)) {
      factor(x)
    } else {
      x
    }
  }),
  row.names = colnames(sce))
sce$Treatment <- relevel(sce$Treatment, "Uninfected")
```

```{r}
fdr <- 0.05
```

# Differential expression between conditions

We perform the DE analysis separately for all cells with the same 'label'.
The actual DE testing is performed on "pseudo-bulk" expression profiles [@tung2016batch], generated by summing counts together for all cells with the same combination of label and sample.
This leverages the resolution offered by single-cell technologies to define the labels, and combines it with the statistical rigor of existing methods for DE analyses involving a small number of samples.

Here we use the clusters as the cell labels, i.e. all cells from the same mouse assigned to the same cluster will have the same label.
We also perform DE testing without regard for the cluster labels.

The [`output/DEGs/`](../output/DEGs/) directory contains CSV files summarising the pseudobulk results and PDFs showing the single-cell expression data for each DEG.

For the differential expression results reported I have used an FDR cutoff of `r fdr`.

## Cluster labels

```{r}
sce$label <- factor(
  paste0("cluster_", sce$cluster),
  levels = paste0("cluster_", levels(sce$cluster)))
```

Ideally, we perform the differential analysis using the cluster labels.
However, for certain cluster/sample combinations we have few cells, and so these comparisons will be underpowered.

```{r}
as.data.frame(colData(sce)) %>%
  group_by(label, Sample) %>%
  dplyr::count() %>%
  tidyr::spread(label, n, fill = 0L) %>%
  knitr::kable(caption = "Number of cells per combination of cluster label and sample.")
```

```{r}
list_of_summed <- lapply(levels(sce$label), function(label) {
  sce <- sce[, sce$label == label]
  label_sample <- paste0(label, ".", sce$Sample)
  sumCountsAcrossCells(sce, label_sample)
})
names(list_of_summed) <- levels(sce$label)
summed <- SingleCellExperiment(
  assays = list(counts = do.call(cbind, list_of_summed)))
colData(summed) <- DataFrame(
  inner_join(
    data.frame(
      label = sapply(strsplit(colnames(summed), "\\."), "[[", 1),
      Sample = sapply(strsplit(colnames(summed), "\\."), "[[", 2)),
    as.data.frame(colData(sce)) %>%
      select(Sample) %>%
      distinct()) %>%
    dplyr::mutate(Treatment = sub("\\_[0-9]", "", Sample)),
  row.names = colnames(summed))
summed$Treatment <- factor(
  summed$Treatment,
  levels = tolower(levels(sce$Treatment)))
summed$label <- factor(summed$label, levels = levels(sce$label))
logcounts(summed) <- cpm(
  counts(summed),
  log = TRUE,
  lib.size = sizeFactors(summed))
```

```{r}
# TODO: Look at Helena's paper and copy figure.
plot_grid(
  plotUMAP(sce, colour_by = "Treatment", point_alpha = 0) + 
    geom_point(aes(colour = colour_by, fill = colour_by), alpha = 1, size = 1) +
    scale_fill_manual(values = treatment_colours, name = "Treatment") + 
    scale_colour_manual(values = treatment_colours, name = "Treatment"),
  scater::plotMDS(summed, colour_by = "Treatment", point_alpha = 0) + 
    geom_point(aes(colour = colour_by, fill = colour_by), alpha = 1, size = 3) +
    scale_fill_manual(values = treatment_colours, name = "Treatment") +
    scale_colour_manual(values = treatment_colours, name = "Treatment"),
  ncol = 2)
```

```{r}
de_results <- list()
for (i in levels(summed$label)) {
  current <- summed[, summed$label == i]
  y <- DGEList(counts(current), samples = colData(current))
  discarded <- isOutlier(y$samples$lib.size, log = TRUE, type = "lower", nmads = 3)
  y <- y[, !discarded]
  keep <- filterByExpr(y, group = current$Treatment)
  y <- y[keep, ]
  y <- calcNormFactors(y)
  design <- model.matrix(~Treatment, y$samples)
  colnames(design) <- sub("Treatment", "", colnames(design))
  if (qr(design)$rank == nrow(design) ||
      qr(design)$rank < ncol(design)) {
    # Skipping labels without contrasts or without 
    # enough residual d.f. to estimate the dispersion.
    message("Skipping ", i)
    next
  }
  y <- estimateDisp(y, design)
  fit <- glmQLFit(y, design, robust = TRUE)
  de_results[[i]] <- fit
}
```

### `infected_vs_uninfected`

The number of DEGs per label is given below.

```{r}
summaries_infected_vs_uninfected <- lapply(
  de_results, 
  function(x) {
    summary(
      decideTests(
        glmQLFTest(
          x,
          coef = "infected"),
        p.value = fdr))[, "infected"]
  })
sum.tab_infected_vs_uninfected <- do.call(
  rbind,
  summaries_infected_vs_uninfected)
sum.tab_infected_vs_uninfected
```

```{r, results = "hide"}
degs_infected_vs_uninfected <- lapply(
  names(de_results),
  function(n) {
    x <- de_results[[n]]
    fit <- glmQLFTest(x, coef = "infected")
    gzout <- gzfile(
      description = here(
        "output", 
        "DEGs", 
        paste0(n, ".DEGs.infected_vs_uninfected.csv.gz")),
      open = "wb")
    write.table(
      x = topTags(
        fit, 
        n = Inf,
        p.value = 1) %>%
        as.data.frame() %>%
        tibble::rownames_to_column("gene_ID"), 
      file = gzout, 
      sep = ",", 
      quote = FALSE, 
      row.names = FALSE,
      col.names = TRUE)
    close(gzout)
    rownames(topTags(fit, p.value = fdr, n = Inf))
  })
names(degs_infected_vs_uninfected) <- names(de_results)

library(org.Hs.eg.db)
for (label in names(degs_infected_vs_uninfected)) {
  degs <- degs_infected_vs_uninfected[[label]]

  # TODO: Add in 'unknown' samples?
  # TODO: Include other clusters?
  .plotHeatmap(
    summed[, summed$label == label],
    color = colorspace::diverging_hsv(100),
    features = degs, 
    # columns = order(summed$Treatment, summed$Sample),
    colour_columns_by = c("Treatment", "Sample"),
    center = TRUE,
    symmetric = TRUE,
    zlim = quantile(as.vector(scale(t(logcounts(summed[, summed$label == label])[degs, ]), scale = FALSE)), c(0.02, 0.98)),
    show_colnames = FALSE,
    main = label,
    # TODO: Need to Capitalise summed$Treatment
    # annotation_colors = list(
    #   Treatment = treatment_colours,
    #   Sample = sample_colours),
    fontsize = 8,
    # TODO: Perhaps cluster columns if only showing data from 1 cluster.
    cluster_cols = FALSE)
  
  .plotHeatmap(
    sce[, sce$label == label],
    color = colorspace::diverging_hsv(100),
    features = degs, 
    columns = order(sce[, sce$label == label]$cluster, sce[, sce$label == label]$Treatment, sce[, sce$label == label]$Sample),
    colour_columns_by = c("cluster", "Treatment", "Sample"),
    center = TRUE,
    symmetric = TRUE,
    zlim = quantile(as.vector(scale(t(logcounts(sce[, sce$label == label])[degs, ]), scale = FALSE)), c(0.02, 0.98)),
    show_colnames = FALSE,
    main = label,
    annotation_colors = list(
      cluster = cluster_colours,
      Treatment = treatment_colours,
      Sample = sample_colours),
    fontsize = 8,
    cluster_cols = FALSE)
  
  .plotHeatmap(
    sce,
    color = colorspace::diverging_hsv(100),
    features = degs, 
    columns = order(sce$cluster, sce$Treatment, sce$Sample),
    colour_columns_by = c("cluster", "Treatment", "Sample"),
    center = TRUE,
    symmetric = TRUE,
    zlim = quantile(as.vector(scale(t(logcounts(sce)[degs, ]), scale = FALSE)), c(0.02, 0.98)),
    show_colnames = FALSE,
    main = label,
    annotation_colors = list(
      cluster = cluster_colours,
      Treatment = treatment_colours,
      Sample = sample_colours),
    fontsize = 8,
    cluster_cols = FALSE)
  
  fit <- de_results[[label]]
  go <- goana(
    glmQLFTest(fit, coef = "infected"),
    geneid = mapIds(org.Hs.eg.db, keys = rownames(fit), column = "ENTREZID", keytype = "SYMBOL"))
  
  # Only keeping biological process terms that are not overly general.
  # Things going Up
  go_up <- go[order(go$P.Up), ]
  # Only keeping biological process terms that are not overly general.
  go_up_useful <- go_up[go_up$Ont == "BP" & go_up$N <= 200, ]
  paged_table(go_up_useful)
  
  # And things going down
  go_down <- go[order(go$P.Down), ]
  # Only keeping biological process terms that are not overly general.
  go_down_useful <- go_down[go_down$Ont == "BP" & go_down$N <= 200, ]
  paged_table(go_down_useful)
  
  kegg <- kegga(
    glmQLFTest(fit, coef = "infected"),
    geneid = mapIds(org.Hs.eg.db, keys = rownames(fit), column = "ENTREZID", keytype = "SYMBOL"))
  
  # Things going Up
  kegg_up <- kegg[order(kegg$P.Up), ]
  paged_table(kegg_up)
  
  # And things going down
  kegg_down <- kegg[order(kegg$P.Down), ]
  paged_table(kegg_down)
}

# TODO: Move This plot into above loop and make a per-cluster PDF.
pdf(
  here("output", "DEGs", "infected_vs_uninfected.cluster.pdf"),
  width = 8,
  height = 6)
for (label in names(degs_infected_vs_uninfected)) {
  degs <- degs_infected_vs_uninfected[[label]]
  for (g in degs) {
    p <- plotExpression(
      sce[, sce$label == label], 
      g,
      x = "Sample",
      colour_by = "Treatment") + 
      scale_fill_manual(values = treatment_colours, name = "Treatment") + 
      stat_summary(
        fun.data = "mean_cl_boot",
        geom = "crossbar",
        colour = "red",
        width = 0.3) + 
      cowplot::theme_cowplot() +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1),
        strip.background = element_blank(),
        strip.text.x = element_blank()) + 
      ggtitle(
        paste0(
          g,
          " (FDR = ", 
          signif(
            topTags(
              glmQLFTest(
                de_results[[label]],
                coef = "infected"),
              n = Inf)[g, "FDR"][[1]], 1),
          ")"),
        subtitle = label)
    print(p)
  }
}
dev.off()
```

## Ignoring cluster labels

**TODO**

# Differential abundance between conditions

In a differential abundance analysis, we test for significant changes in per-label cell abundance across conditions.
This will reveal which cell types are depleted or enriched due to genotype differences, which is arguably just as interesting as changes in expression within each cell type.
We effectively treat scRNA-seq as a "super-FACS" technology for defining relevant subpopulations using the entire transcriptome.

```{r}
fdr <- 0.05
```

**For the differential abundance results reported I have used an FDR cutoff of `r fdr`.**

## Cluster labels

```{r}
sce$label <- factor(
  paste0("cluster_", sce$cluster),
  levels = paste0("cluster_", levels(sce$cluster)))
```

Ideally, we perform the differential analysis using the cluster labels.
However, for certain cluster/sample combinations we have few cells, meaning these comparisons will be underpowered and so we do not test them.

```{r}
as.data.frame(colData(sce)) %>%
  group_by(label, Sample) %>%
  dplyr::count() %>%
  tidyr::spread(label, n, fill = 0L) %>%
  knitr::kable(caption = "Number of cells per combination of cluster label and sample.")
```

```{r}
abundances <- table(sce$label, sce$Sample)
abundances <- unclass(abundances) 
extra.info <- colData(sce)[match(colnames(abundances), sce$Sample), ]
y <- DGEList(abundances, samples = extra.info)
keep <- filterByExpr(y, group=y$samples$Treatment)
design <- model.matrix(~Treatment, y$samples)
colnames(design) <- sub("Treatment", "", colnames(design))
y <- estimateDisp(y, design, trend = "none")
fit <- glmQLFit(y, design, robust = TRUE, abundance.trend = FALSE)
```

### `infected_vs_uninfected`

The number of differentially abundance clusters is given below.
A positive `logFC` means enrichment of that cluster in the `infected` vs. the `uninfected`.

```{r}
res <- glmQLFTest(fit, coef = "Infected")
summary(decideTests(res, p.value = fdr))
```

The full results are given below.

```{r}
topTags(res, n = Inf)
```

**TODO:** Look at OSCA for full DA analysis.

# TODOs

- [ ] Get DEGs in common across clusters
