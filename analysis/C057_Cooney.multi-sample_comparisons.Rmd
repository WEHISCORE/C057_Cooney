---
title: "Multi-sample comparisons with the Cooney (C057) memory CD4+ T-cell data set"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: Single Cell Open Research Endeavour (SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: radix::radix_article
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(here)
library(janitor)
library(BiocStyle)
library(BiocParallel)
library(pheatmap)

source(here("analysis", "helper_functions.R"))

# NOTE: Using multiple cores siezes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 1L, 9L))
register(MulticoreParam(workers = getOption("mc.cores")))
knitr::opts_chunk$set(
  fig.path = "C057_Cooney_multi-sample_comparisons_files/")
```

# Introduction

Differential analyses of multi-condition scRNA-seq experiments can be broadly split into two categories: differential expression (DE) and differential abundance (DA) analyses.
The former tests for changes in expression between conditions for cells of the same type that are present in both conditions, while the latter tests for changes in the composition of cell types (or states, etc.) between conditions.

The aim of this study is to identify differentially expressed genes between infected and uninfected samples.

```{r}
library(SingleCellExperiment)
library(dplyr)
library(scater)
library(edgeR)

sce <- readRDS(here("data", "SCEs", "C057_Cooney.annotated.SCE.rds"))
```

```{r}
hto_to_sample_df <- as.data.frame(colData(sce)) %>%
  dplyr::select(hto_cluster, HTO, Sample, Treatment, Replicate) %>%
  dplyr::distinct()

# Some useful colours
hto_cluster_colours <- setNames(
  colorblindr::palette_OkabeIto,
  levels(sce$hto_cluster))
hto_cluster_colours <- hto_cluster_colours[!is.na(names(hto_cluster_colours))]
hto_colours <- hto_cluster_colours
names(hto_colours) <- dplyr::inner_join(
  data.frame(hto_cluster = names(hto_cluster_colours)),
  hto_to_sample_df) %>%
  dplyr::pull(HTO)
sample_colours <- hto_cluster_colours
names(sample_colours) <- dplyr::inner_join(
  data.frame(hto_cluster = names(sample_colours)),
  hto_to_sample_df) %>%
  dplyr::pull(Sample)
treatment_colours <- c(
  "Infected" = "#e41a1c",
  "Uninfected" = "#377eb8",
  "Unknown" = "grey70")
# NOTE: No replicate_colours because we won't ever colour by this.
cluster_colours <- setNames(
  Polychrome::green.armytage.colors(nlevels(sce$cluster)),
  levels(sce$cluster))
```

We discard the 'Unknown' samples as these cannot be used for differential analyses.

```{r}
sce <- sce[, sce$Sample != "Unknown"]
# NOTE: Update the factor columns.
colData(sce) <- DataFrame(
  lapply(colData(sce), function(x) {
    if (is.factor(x)) {
      factor(x)
    } else {
      x
    }
  }),
  row.names = colnames(sce))
sce$Treatment <- relevel(sce$Treatment, "Uninfected")
```

```{r}
fdr <- 0.05
```

# Differential expression between conditions

We perform the DE analysis separately for all cells with the same 'label'.
The actual DE testing is performed on "pseudobulk" expression profiles [@tung2016batch], generated by summing counts together for all cells with the same combination of label and sample.

This leverages the resolution offered by single-cell technologies to define the labels, and combines it with the statistical rigor of existing methods for DE analyses involving a small number of samples.

Here we use the clusters as the cell labels, i.e. all cells from the same mouse assigned to the same cluster will have the same label.
We also perform DE testing without regard for the cluster labels.

The [`output/DEGs/`](../output/DEGs/) directory contains CSV files summarising the pseudobulk results and PDFs showing the single-cell expression data for each DEG.

For the differential expression results reported I have used an FDR cutoff of `r fdr`.

## Cluster labels

```{r}
sce$label <- factor(
  paste0("cluster_", sce$cluster),
  levels = paste0("cluster_", levels(sce$cluster)))
```

Certain cluster/sample combinations we have few cells, and so these comparisons may be underpowered.
There are also clusters that are largely treatment-specific, as shown in Figure \@ref(fig:tsne) and the table below.

```{r tsne, fig.cap = "t-SNE visualization colored by subpopulation ID (left) and group ID (right)."}
# TODO: Describe figure.
cowplot::plot_grid(
  plotTSNE(sce, colour_by = "cluster", point_alpha = 0) + 
    geom_point(aes(colour = colour_by), size = 0.1, alpha = 0.5) +
    scale_colour_manual(values = cluster_colours, name = "cluster"),
  plotTSNE(sce, colour_by = "Treatment", point_alpha = 0) + 
    geom_point(aes(colour = colour_by), size = 0.1, alpha = 0.5) +
    scale_colour_manual(values = treatment_colours, name = "Treatment"),
  ncol = 2,
  align = "v")
```

```{r}
as.data.frame(colData(sce)) %>%
  group_by(label, Sample) %>%
  dplyr::count() %>%
  tidyr::spread(label, n, fill = 0L) %>%
  knitr::kable(caption = "Number of cells per combination of cluster label and sample.")
```

```{r}
list_of_summed <- lapply(levels(sce$label), function(label) {
  sce <- sce[, sce$label == label]
  label_sample <- paste0(label, ".", sce$Sample)
  sumCountsAcrossCells(sce, label_sample)
})
names(list_of_summed) <- levels(sce$label)
summed <- SingleCellExperiment(
  assays = list(counts = do.call(cbind, list_of_summed)))
colData(summed) <- DataFrame(
  inner_join(
    data.frame(
      label = sapply(strsplit(colnames(summed), "\\."), "[[", 1),
      Sample = sapply(strsplit(colnames(summed), "\\."), "[[", 2)),
    as.data.frame(colData(sce)) %>%
      select(Sample) %>%
      distinct()) %>%
    dplyr::mutate(Treatment = sub("\\_[0-9]", "", Sample)),
  row.names = colnames(summed))
summed$Treatment <- factor(
  stringr::str_to_sentence(summed$Treatment),
  levels = levels(sce$Treatment))
summed$cluster <- factor(sub("cluster\\_", "", summed$label), levels(sce$cluster))
summed$label <- factor(summed$label, levels = levels(sce$label))
logcounts(summed) <- cpm(
  counts(summed),
  log = TRUE,
  lib.size = sizeFactors(summed))
```

Following aggregation of counts, we can visualise the pseudobulk samples using an multidimensional scaling (MDS) plot (Figure \@ref(fig:mds)).
This can be used to check that the pseudobulk samples still largely cluster by our cluster labels and see if there is some treatment-specific differences within the clusters.

```{r mds, fig.cap = "Pseudobulk-level multidimensional scaling (MDS) plot. Each point represents one cluster-sample instance; points are colored by cluster and shaped by group ID."}
scater::plotMDS(
  summed,
  colour_by = "cluster",
  shape_by = "Treatment",
  point_alpha = 0) + 
  geom_point(aes(colour = colour_by, shape = shape_by), alpha = 1, size = 3) +
  scale_colour_manual(values = cluster_colours, name = "cluster")
```

We then run a differential expression analysis separately for each cluster.

```{r}
de_results <- list()
for (i in levels(summed$label)) {
  current <- summed[, summed$label == i]
  y <- DGEList(counts(current), samples = colData(current))
  discarded <- isOutlier(y$samples$lib.size, log = TRUE, type = "lower", nmads = 3)
  y <- y[, !discarded]
  keep <- filterByExpr(y, group = current$Treatment)
  y <- y[keep, ]
  y <- calcNormFactors(y)
  design <- model.matrix(~Treatment, y$samples)
  colnames(design) <- sub("Treatment", "", colnames(design))
  if (qr(design)$rank == nrow(design) ||
      qr(design)$rank < ncol(design)) {
    # Skipping labels without contrasts or without 
    # enough residual d.f. to estimate the dispersion.
    message("Skipping ", i)
    next
  }
  y <- estimateDisp(y, design)
  fit <- glmQLFit(y, design, robust = TRUE)
  de_results[[i]] <- fit
}
```

### `infected_vs_uninfected`

The number of DEGs per label is given below.

```{r}
summaries_infected_vs_uninfected <- lapply(
  de_results, 
  function(x) {
    summary(
      decideTests(
        glmQLFTest(
          x,
          coef = "Infected"),
        p.value = fdr))[, "Infected"]
  })
sum.tab_infected_vs_uninfected <- do.call(
  rbind,
  summaries_infected_vs_uninfected)
knitr::kable(sum.tab_infected_vs_uninfected)
```

```{r, results = "hide"}
dir.create(here("output", "DEGs", "cluster_labels"))

degs_infected_vs_uninfected <- lapply(
  names(de_results),
  function(n) {
    x <- de_results[[n]]
    fit <- glmQLFTest(x, coef = "Infected")
    gzout <- gzfile(
      description = here(
        "output", 
        "DEGs", 
        "cluster_labels",
        paste0(n, ".DEGs.infected_vs_uninfected.csv.gz")),
      open = "wb")
    write.table(
      x = topTags(
        fit, 
        n = Inf,
        p.value = 1) %>%
        as.data.frame() %>%
        tibble::rownames_to_column("gene_ID"), 
      file = gzout, 
      sep = ",", 
      quote = FALSE, 
      row.names = FALSE,
      col.names = TRUE)
    close(gzout)
    rownames(topTags(fit, p.value = fdr, n = Inf))
  })
names(degs_infected_vs_uninfected) <- names(de_results)

degs <- lapply(
  de_results,
  function(x) {
    rownames(topTags(glmQLFTest(x, coef = "Infected"), p.value = fdr, n = Inf))
    })
common_degs <- sort(table(unlist(degs)), decreasing = TRUE)
```

A survey of the DEGs from all clusters identifies a number of genes that are differentially expressed across a number of clusters.

```{r}
rmarkdown::paged_table(
  as.data.frame(common_degs) %>% 
    dplyr::rename(Gene = Var1, `# Clusters gene is DE` = Freq))
```

Figure \@ref(fig:degs-heatmap) is a heatmap of the pseudobulk-level log-expression values of some differentially expressed genes with particularly large log fold changes between infected and uninfected cells.

```{r degs-heatmap, fig.cap = "Heatmap of pseudobulk-level log-expression values normalized to the mean of uninfected samples; rows correspond to genes, columns to cluster-sample combinations. Included is the union of DEGs ($FDR < 0.05$, $|logFC| > 1$, using the 'TREAT' method) across all clusters. Data is split vertically by cluster (of cells) and vertically by consensus clustering of genes; top and bottom 1% logFC quantiles were truncated for visualization."}
degs <- Reduce(
  union,
  lapply(de_results, function(x) {
    rownames(
      topTags(glmTreat(x, coef = "Infected", lfc = 1), p.value = fdr, n = Inf))
  }))
mat <- logcounts(summed)[degs, ]
row_means <- rowMeans(mat[, summed$Treatment == "Uninfected"])
mat <- apply(mat, 2, `-`, row_means)
zlim <- quantile(as.vector(mat), c(0.01, 0.99))
mat[mat < zlim[1]] <- zlim[1]
mat[mat > zlim[2]] <- zlim[2]
pheatmap(
  mat[, order(summed$cluster, summed$Treatment, summed$Sample)],
  color = colorspace::diverging_hsv(100),
  scale = "none",
  cluster_rows = TRUE,
  cluster_cols = FALSE,
  gaps_col = seq(6, ncol(summed), 6),
  show_colnames = FALSE,
  main = "DEGs",
  annotation_col = as.data.frame(colData(summed))[, c("cluster", "Treatment")],
  annotation_colors = list(
    cluster = cluster_colours,
    Treatment = treatment_colours),
  fontsize = 8)
```

The [`output/DEGs/cluster_labels/`](../output/DEGs/cluster_labels/) directory contains cluster-specific heatmaps of differentially expressed genes ($FDR < 0.05$; up to 100 genes shown).

```{r, results = "hide"}
pdf(
  here(
    "output",
    "DEGs",
    "cluster_labels",
    "cluster_labels.infected_vs_uninfected.heatmap.pdf"),
  width = 7, 
  height = 10)
for (label in names(degs_infected_vs_uninfected)) {
  degs <- degs_infected_vs_uninfected[[label]]
  # NOTE: Truncate at 100 genes
  degs <- degs[seq_len(min(length(degs), 100))]

  # NOTE: Need at least 2 genes to cluster.
  if (length(degs)) {
    .plotHeatmap(
      summed[, summed$label == label],
      color = colorspace::diverging_hsv(100),
      features = degs, 
      colour_columns_by = c("Treatment"),
      center = TRUE,
      symmetric = TRUE,
      zlim = quantile(
        as.vector(
          scale(
            t(logcounts(summed[, summed$label == label])[degs, , drop = FALSE]),
            scale = FALSE)),
        c(0.01, 0.99)),
      show_colnames = FALSE,
      main = label,
      annotation_colors = list(Treatment = treatment_colours),
      fontsize = 8,
      cluster_cols = FALSE,
      cluster_rows = length(degs) >= 2)
  }
}
dev.off()
```

We perform gene ontology (GO) enrichment analyses of these cluster-specific DEG lists.
To focus this analysis, we restrict the results to GO terms with the 'biological pathway' ontology term and containing up to 200 genes.

**TODO:** Give an example of, say, the top-20 GO terms in one particularl cluster.

```{r}
library(org.Hs.eg.db)

# TODO: Just write tables to disk as CSVs.
for (label in names(degs_infected_vs_uninfected)) {
  fit <- de_results[[label]]
  go <- goana(
      glmQLFTest(fit, coef = "Infected"),
      geneid = mapIds(
        org.Hs.eg.db,
        keys = rownames(fit),
        column = "ENTREZID",
        keytype = "SYMBOL"))
  if (nrow(go) == 0) {
    next
  }
  
  # Things going Up
  go_up <- go[order(go$P.Up), ]
  # Only keeping biological process terms that are not overly general.
  go_up_useful <- go_up[go_up$Ont == "BP" & go_up$N <= 200, ]
  go_up_useful %>%
    dplyr::mutate(label = label) %>%
    dplyr::select(label, everything()) %>%
    rmarkdown::paged_table()
  
  # And things going down
  go_down <- go[order(go$P.Down), ]
  # Only keeping biological process terms that are not overly general.
  go_down_useful <- go_down[go_down$Ont == "BP" & go_down$N <= 200, ]
  go_down_useful %>%
    dplyr::mutate(label = label) %>%
    dplyr::select(label, everything()) %>%
    rmarkdown::paged_table()}
```

```{r}
knitr::knit_exit()
```

```{r}
# TODO: Just write tables to disk as CSVs.
for (label in names(degs_infected_vs_uninfected)) {
  
  kegg <- kegga(
    glmQLFTest(fit, coef = "infected"),
    geneid = mapIds(org.Hs.eg.db, keys = rownames(fit), column = "ENTREZID", keytype = "SYMBOL"))
  
  # Things going Up
  kegg_up <- kegg[order(kegg$P.Up), ]
  paged_table(kegg_up)
  
  # And things going down
  kegg_down <- kegg[order(kegg$P.Down), ]
  paged_table(kegg_down)
}
```

```{r}
# TODO: Make a per-cluster PDF.
pdf(
  here("output", "DEGs", "infected_vs_uninfected.cluster.pdf"),
  width = 8,
  height = 6)
for (label in names(degs_infected_vs_uninfected)) {
  degs <- degs_infected_vs_uninfected[[label]]
  for (g in degs) {
    p <- plotExpression(
      sce[, sce$label == label], 
      g,
      x = "Sample",
      colour_by = "Treatment") + 
      scale_fill_manual(values = treatment_colours, name = "Treatment") + 
      stat_summary(
        fun.data = "mean_cl_boot",
        geom = "crossbar",
        colour = "red",
        width = 0.3) + 
      cowplot::theme_cowplot() +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1),
        strip.background = element_blank(),
        strip.text.x = element_blank()) + 
      ggtitle(
        paste0(
          g,
          " (FDR = ", 
          signif(
            topTags(
              glmQLFTest(
                de_results[[label]],
                coef = "infected"),
              n = Inf)[g, "FDR"][[1]], 1),
          ")"),
        subtitle = label)
    print(p)
  }
}
dev.off()
```

## Ignoring cluster labels

**TODO**

# Differential abundance between conditions

In a differential abundance analysis, we test for significant changes in per-label cell abundance across conditions.
This will reveal which cell types are depleted or enriched due to genotype differences, which is arguably just as interesting as changes in expression within each cell type.
We effectively treat scRNA-seq as a "super-FACS" technology for defining relevant subpopulations using the entire transcriptome.

```{r}
fdr <- 0.05
```

**For the differential abundance results reported I have used an FDR cutoff of `r fdr`.**

## Cluster labels

```{r}
sce$label <- factor(
  paste0("cluster_", sce$cluster),
  levels = paste0("cluster_", levels(sce$cluster)))
```

Ideally, we perform the differential analysis using the cluster labels.
However, for certain cluster/sample combinations we have few cells, meaning these comparisons will be underpowered and so we do not test them.

```{r}
as.data.frame(colData(sce)) %>%
  group_by(label, Sample) %>%
  dplyr::count() %>%
  tidyr::spread(label, n, fill = 0L) %>%
  knitr::kable(caption = "Number of cells per combination of cluster label and sample.")
```

```{r}
abundances <- table(sce$label, sce$Sample)
abundances <- unclass(abundances) 
extra.info <- colData(sce)[match(colnames(abundances), sce$Sample), ]
y <- DGEList(abundances, samples = extra.info)
keep <- filterByExpr(y, group=y$samples$Treatment)
design <- model.matrix(~Treatment, y$samples)
colnames(design) <- sub("Treatment", "", colnames(design))
y <- estimateDisp(y, design, trend = "none")
fit <- glmQLFit(y, design, robust = TRUE, abundance.trend = FALSE)
```

### `infected_vs_uninfected`

The number of differentially abundance clusters is given below.
A positive `logFC` means enrichment of that cluster in the `infected` vs. the `uninfected`.

```{r}
res <- glmQLFTest(fit, coef = "Infected")
summary(decideTests(res, p.value = fdr))
```

The full results are given below.

```{r}
topTags(res, n = Inf)
```

**TODO:** Look at OSCA for full DA analysis.

# TODOs

- [ ] Get DEGs in common across clusters
