---
title: "Selection of biologically relevant cells for the Cooney (C057) memory CD4+ T-cell data set"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: Single Cell Open Research Endeavour (SCORE), WEHI
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: distill::distill_article
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(SingleCellExperiment)
library(here)
library(scater)
library(scran)
library(ggplot2)
library(cowplot)
library(edgeR)
library(Glimma)
library(BiocParallel)
library(patchwork)

source(here("code", "helper_functions.R"))

# NOTE: Using multiple cores seizes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 2L, 8L))
register(MulticoreParam(workers = getOption("mc.cores")))

knitr::opts_chunk$set(fig.path = "C057_Cooney.cell_selection_files/")
```

# Motivation

scRNA-seq datasets generated with 10X will include droplets that are not relevant to the study, even after the initial quality control, which we don't want to include in downstream analyses.
In this section aim to filter out these 'unwanted' droplets and retain only those droplets containing 'biologically relevant' cells.
Examples of unwanted droplets include:

- Droplets containing stripped nuclei
- Droplets containing more than one cell ('doublets')
- Droplets without phenotype data, such as droplets for which we can't infer the sample identify based on cell hashing or genetic variation data
- Droplets containing unwanted cell types, such as those that might sneak through a FACS or magnetic bead enrichment sample preparation

Once we are confident that we have selected the biologically relevant cells, we will perform data integration (if necessary) and a further round of clustering in preparation for downstream analysis.

The removal of unwanted droplets is an iterative process where at each step we:

1. Identify cluster(s) enriched for unwanted droplets. The exact criteria used to define 'unwanted' will depend on the type of droplets we are trying to identify at each step.
    a. Perform diagnostic checks to ensure we aren't discarding biologically relevant droplets.
    b. Remove the unwanted cells.
2. Re-process the remaining droplets.
    a. Identify HVGs.
    b. Perform dimensionality reduction (PCA and UMAP).
    c. Cluster droplets.

Clustering is a critical component of this process, so we discuss it in further detail in the next subsection.

## Clustering

Clustering is an unsupervised learning procedure that is used in scRNA-seq data analysis to empirically define groups of cells with similar expression profiles.
Its primary purpose is to summarize the data in a digestible format for human interpretation. 
This allows us to describe population heterogeneity in terms of discrete labels that are easily understood, rather than attempting to comprehend the high-dimensional manifold on which the cells truly reside.
Clustering is thus a critical step for extracting biological insights from scRNA-seq data.

Clustering calculations are usually performed using the top PCs to take advantage of data compression and denoising^[But see the 'Data integration' section of this report for an exception to the rule.].

### Clusters vs. cell types

It is worth stressing the distinction between clusters and cell types.
The former is an empirical construct while the latter is a biological truth (albeit a vaguely defined one).
For this reason, questions like "what is the true number of clusters?" are usually meaningless.
We can define as many clusters as we like, with whatever algorithm we like - each clustering will represent its own partitioning of the high-dimensional expression space, and is as "real" as any other clustering.

A more relevant question is "how well do the clusters approximate the cell types?"
Unfortunately, this is difficult to answer given the context-dependent interpretation of biological truth.
Some analysts will be satisfied with resolution of the major cell types; other analysts may want resolution of subtypes; and others still may require resolution of different states (e.g., metabolic activity, stress) within those subtypes.
Two clusterings can also be highly inconsistent yet both valid, simply partitioning the cells based on different aspects of biology.
Indeed, asking for an unqualified "best" clustering is akin to asking for the best magnification on a microscope without any context.

It is helpful to realize that clustering, like a microscope, is simply a tool to explore the data.
We can zoom in and out by changing the resolution of the clustering parameters, and we can experiment with different clustering algorithms to obtain alternative perspectives of the data.
This iterative approach is entirely permissible for data exploration, which constitutes the majority of all scRNA-seq data analysis.

## Graph-based clustering

We build a shared nearest neighbour graph [@xu2015identification] and use the Louvain algorithm to identify clusters.
We would build the graph using the principal components.

# Preparing the data

We start from the preprocessed *SingleCellExperiment* object created in ['Preprocessing the Cooney (C057) memory CD4+ T-cell data set'](C057_Cooney.preprocess.html).

```{r}
sce <- readRDS(here("data", "SCEs", "C057_Cooney.preprocessed.SCE.rds"))

# data frames containing co-ordinates and factors for creating reduced 
# dimensionality plots.
umap_df <- cbind(
  data.frame(
    x = reducedDim(sce, "UMAP")[, 1],
    y = reducedDim(sce, "UMAP")[, 2]),
  as.data.frame(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")]))

# Some useful colours
sample_colours <- setNames(
  unique(sce$sample_colours),
  unique(names(sce$sample_colours)))
treatment_colours <- setNames(
  unique(sce$treatment_colours),
  unique(names(sce$treatment_colours)))

# Some useful gene sets
mito_set <- rownames(sce)[which(rowData(sce)$CHR == "MT")]
ribo_set <- grep("^RP(S|L)", rownames(sce), value = TRUE)
# NOTE: A more curated approach for identifying ribosomal protein genes 
#       (https://github.com/Bioconductor/OrchestratingSingleCellAnalysis-base/blob/ae201bf26e3e4fa82d9165d8abf4f4dc4b8e5a68/feature-selection.Rmd#L376-L380)
library(msigdbr)
c2_sets <- msigdbr(species = "Homo sapiens", category = "C2")
ribo_set <- union(
  ribo_set,
  c2_sets[c2_sets$gs_name == "KEGG_RIBOSOME", ]$human_gene_symbol)
```

## Initial clustering

```{r}
set.seed(75699)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
stopifnot(nlevels(sce$cluster) == 10)
umap_df$cluster <- sce$cluster
cluster_colours <- setNames(
  Polychrome::glasbey.colors(nlevels(sce$cluster) + 1)[-1],
  levels(sce$cluster))
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:clusterplot-umap) and broken down by experimental factors in Figure \@ref(fig:cluster-barplot).

```{r clusterplot-umap, fig.cap = "UMAP plot, where each point represents a droplet and is coloured according to the legend.", fig.asp = 0.7}
plot_grid(
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = cluster), size = 0.25) +
    scale_colour_manual(values = cluster_colours) + 
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2"),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Treatment), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = treatment_colours),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Sample), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = sample_colours),
  ncol = 2, 
  align = "v")
```

```{r cluster-barplot, fig.asp = 1 / 4, fig.cap = "Breakdown of clusters by experimental factors."}
plot_grid(
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Sample")])) + 
    geom_bar(
      aes(x = cluster, fill = Sample),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = sample_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Treatment")])) + 
    geom_bar(
      aes(x = cluster, fill = Treatment),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = treatment_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, "cluster", drop = FALSE])) + 
    geom_bar(aes(x = cluster, fill = cluster)) +
    coord_flip() +
    ylab("Number of droplets") +
    scale_fill_manual(values = cluster_colours) +
    theme_cowplot(font_size = 5) + 
    guides(fill = FALSE),
  align = "h",
  ncol = 3)
```

Notably:

- Some of the clusters are highly treatment-specific.
- Many of the clusters are enriched for `ambiguous` droplets.

# Clusters enriched for `ambiguous` droplets

This analysis is done in two parts: a [First pass] and a [Refinement].

## First pass

### Motivation

```{r, results = "hide"}
prop_ambiguous <- tapply(
  sce$Sample == "ambiguous",
  sce$cluster,
  function(x) sum(x) / length(x))
sort(prop_ambiguous)
prop_ambiguous_outliers <- isOutlier(
  prop_ambiguous,
  type = "higher",
  # NOTE: Want the cluster(s) that are **way** out there.
  nmads = 5)
ambiguous_enriched_clusters <- levels(sce$cluster)[prop_ambiguous_outliers]
stopifnot(identical(ambiguous_enriched_clusters, c("2", "7", "8", "9")))
```

There are several clusters with unusually large proportions of droplets being of `ambiguous` origin, namely clusters `r glue::glue_collapse(ambiguous_enriched_clusters, sep = ", ", last = ", and ")` (proportions = `r glue::glue_collapse(round(prop_ambiguous[ambiguous_enriched_clusters], 2), ", ", last = ", and ")`, respectively).

These droplets cannot be assigned to a sample of origin and so are not useful in downstream analyses.
However, before we exclude them, we want to ensure we aren't systematically excluding a biologically relevant cell population.

We would further like to know that this isn't systematically excluding droplets from a particular sample or treatment group.
This is challenging because by definition most of these droplets are of `ambiguous` origin.
However, we can check if the 'labelled' droplets in those clusters are enriched for particular samples.

### Analysis

Figure \@ref(fig:ambiguous-enriched-clusters-umap) highlights droplets from these clusters on the UMAP plot, showing that they are largely distinct from the bulk of droplets from the dataset.

```{r ambiguous-enriched-clusters-umap, fig.cap = "UMAP plot highlighting droplets from clusters that are enriched for `ambiguous` droplets. Cluster labels are overlaid on cluster centroids."}
plotUMAP(
  sce,
  colour_by = data.frame(
    `ambiguous enriched cluster` = sce$cluster %in% ambiguous_enriched_clusters),
  text_by = "cluster")
```

Figure \@ref(fig:ambiguous-enriched-clusters-qc-plot) shows that the QC metrics of droplets from these clusters are distinct from the other clusters, having smaller library sizes and fewer genes detected (but no difference in mitochondrial proportions).

```{r ambiguous-enriched-clusters-qc-plot, fig.cap = "QC metrics of droplets by cluster, highlighting droplets from clusters that are enriched for `ambiguous` droplets (orange)."}
plot_grid(
  plotColData(
    sce, 
    "sum", 
    x = "cluster", 
    colour_by = data.frame(
      `ambiguous enriched cluster` = 
        sce$cluster %in% ambiguous_enriched_clusters)) +
    scale_y_log10() + 
    guides(fill = FALSE),
  plotColData(
    sce, 
    "detected", 
    x = "cluster", 
    colour_by = data.frame(
      `ambiguous enriched cluster` = 
        sce$cluster %in% ambiguous_enriched_clusters)) +
    scale_y_log10() + 
    guides(fill = FALSE),
  plotColData(
  sce,
  "subsets_Mito_percent",
  x = "cluster",
  colour_by = data.frame(
      `ambiguous enriched cluster` = 
        sce$cluster %in% ambiguous_enriched_clusters)) + 
    guides(fill = FALSE),
  align = "v",
  ncol = 2)
```

This is particularly clear for clusters 2, 7, and 9, whereas cluster 8 comprises droplets with abnormal and typical QC metrics.
Droplets with small library sizes are likely to contain ambient RNA rather than intact cells.

#### Checking for removal of biologically relevant subpopulations

We check for cell type loss by looking for systematic differences in gene expression between the discarded and retained droplets, doing this separately for each of the suspicious clusters.

##### Cluster 2

```{r}
keep <- !sce$cluster == "2"
lost <- calculateAverage(counts(sce)[, !keep])
kept <- calculateAverage(counts(sce)[, keep])
logged <- cpm(cbind(lost, kept), log = TRUE, prior.count = 2)
logFC <- logged[, 1] - logged[, 2]
abundance <- rowMeans(logged)
```

Figure \@ref(fig:ambiguous-enriched-clusters-2-md-plot) shows the result of this analysis, highlighting that there are few genes with a large $logFC$ between 'lost' and 'kept' droplets.

<aside>
An interactive version of Figure \@ref(fig:ambiguous-enriched-clusters-2-md-plot) is available from [`output/glimma-plots/ambiguous-enriched-clusters-2-md-plot.html`](../output/glimma-plots/ambiguous-enriched-clusters-2-md-plot.html).
</aside>

```{r ambiguous-enriched-clusters-2-md-plot, fig.cap = "Log-fold change in expression in the discarded cells compared to the retained cells. Each point represents a gene with mitochondrial transcripts in blue and ribosomal protein genes in orange. Dashed red lines indicate $|logFC| = 1$", fig.asp = 0.7}
is_mito <- rownames(sce) %in% mito_set
is_ribo <- rownames(sce) %in% ribo_set
plot(
  abundance,
  logFC,
  xlab = "Average count",
  ylab = "Log-FC (lost/kept)",
  pch = 16)
points(
  abundance[is_mito],
  logFC[is_mito],
  col = "dodgerblue",
  pch = 16,
  cex = 1)
points(
  abundance[is_ribo],
  logFC[is_ribo],
  col = "orange",
  pch = 16,
  cex = 1)
abline(h = c(-1, 1), col = "red", lty = 2)

glMDPlot(
  x = data.frame(abundance = abundance, logFC = logFC),
  xval = "abundance", 
  yval = "logFC",
  counts = cbind(lost, kept),
    anno = cbind(
      as.data.frame(rowData(sce)), 
      data.frame(GeneID = rownames(sce), stringsAsFactors = FALSE)),
  display.columns = c("Symbol", "ID", "CHR"),
  groups = factor(c("lost", "kept")),
  samples = c("lost", "kept"),
  status = unname(ifelse(is_mito, 1, ifelse(is_ribo, -1, 0))),
  transform = FALSE,
  main = "lost vs. kept",
  side.ylab = "Average count",
  cols = c("orange", "black", "dodgerBlue"),
  path = here("output"),
  html = "ambiguous-enriched-clusters-2-md-plot",
  launch = FALSE)
```

If the discarded pool is enriched for a certain cell type, we should observe increased expression of the corresponding marker genes.

Another concern is whether the cells removed by this procedure are preferentially derive from particular experimental groups.
Reassuringly, Figure \@ref(fig:ambiguous-enriched-clusters-2-barplot-highlighting-removed-droplets) shows that this is not the case; most of the removed droplets are `ambiguous`, as we expect from the above analysis.

```{r ambiguous-enriched-clusters-2-barplot-highlighting-removed-droplets, fig.cap = "Droplets retained after excluding droplets from cluster 2, stratified by `Sample`."}
ggplot(
  data.frame(Sample = sce$Sample, keep = sce$cluster != "2")) + 
  geom_bar(aes(x = Sample, fill = keep)) + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 9) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

##### Cluster 7

```{r}
keep <- !sce$cluster == "7"
lost <- calculateAverage(counts(sce)[, !keep])
kept <- calculateAverage(counts(sce)[, keep])
logged <- cpm(cbind(lost, kept), log = TRUE, prior.count = 2)
logFC <- logged[, 1] - logged[, 2]
abundance <- rowMeans(logged)
```

Figure \@ref(fig:ambiguous-enriched-clusters-7-md-plot) shows the result of this analysis, highlighting that there are few genes with a large $logFC$ between 'lost' and 'kept' droplets.

<aside>
An interactive version of Figure \@ref(fig:ambiguous-enriched-clusters-7-md-plot) is available from [`output/glimma-plots/ambiguous-enriched-clusters-7-md-plot.html`](../output/glimma-plots/ambiguous-enriched-clusters-7-md-plot.html).
</aside>

```{r ambiguous-enriched-clusters-7-md-plot, fig.cap = "Log-fold change in expression in the discarded cells compared to the retained cells. Each point represents a gene with mitochondrial transcripts in blue and ribosomal protein genes in orange. Dashed red lines indicate $|logFC| = 1$", fig.asp = 0.7}
is_mito <- rownames(sce) %in% mito_set
is_ribo <- rownames(sce) %in% ribo_set
plot(
  abundance,
  logFC,
  xlab = "Average count",
  ylab = "Log-FC (lost/kept)",
  pch = 16)
points(
  abundance[is_mito],
  logFC[is_mito],
  col = "dodgerblue",
  pch = 16,
  cex = 1)
points(
  abundance[is_ribo],
  logFC[is_ribo],
  col = "orange",
  pch = 16,
  cex = 1)
abline(h = c(-1, 1), col = "red", lty = 2)

glMDPlot(
  x = data.frame(abundance = abundance, logFC = logFC),
  xval = "abundance", 
  yval = "logFC",
  counts = cbind(lost, kept),
    anno = cbind(
      as.data.frame(rowData(sce)), 
      data.frame(GeneID = rownames(sce), stringsAsFactors = FALSE)),
  display.columns = c("Symbol", "ID", "CHR"),
  groups = factor(c("lost", "kept")),
  samples = c("lost", "kept"),
  status = unname(ifelse(is_mito, 1, ifelse(is_ribo, -1, 0))),
  transform = FALSE,
  main = "lost vs. kept",
  side.ylab = "Average count",
  cols = c("orange", "black", "dodgerBlue"),
  path = here("output"),
  html = "ambiguous-enriched-clusters-7-md-plot",
  launch = FALSE)
```

If the discarded pool is enriched for a certain cell type, we should observe increased expression of the corresponding marker genes.

Another concern is whether the cells removed by this procedure are preferentially derive from particular experimental groups.
Reassuringly, Figure \@ref(fig:ambiguous-enriched-clusters-7-barplot-highlighting-removed-droplets) shows that this is not the case; most of the removed droplets are `ambiguous`, as we expect from the above analysis.

```{r ambiguous-enriched-clusters-7-barplot-highlighting-removed-droplets, fig.cap = "Droplets retained after excluding droplets from cluster 5, stratified by `Sample`."}
ggplot(
  data.frame(Sample = sce$Sample, keep = sce$cluster != "7")) + 
  geom_bar(aes(x = Sample, fill = keep)) + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 9) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

##### Cluster 8

```{r}
keep <- !sce$cluster == "8"
lost <- calculateAverage(counts(sce)[, !keep])
kept <- calculateAverage(counts(sce)[, keep])
logged <- cpm(cbind(lost, kept), log = TRUE, prior.count = 2)
logFC <- logged[, 1] - logged[, 2]
abundance <- rowMeans(logged)
```

Figure \@ref(fig:ambiguous-enriched-clusters-8-md-plot) shows the result of this analysis, highlighting that there are a number of genes with a large $logFC$ between 'lost' and 'kept' droplets.

<aside>
An interactive version of Figure \@ref(fig:ambiguous-enriched-clusters-8-md-plot) is available from [`output/glimma-plots/ambiguous-enriched-clusters-8-md-plot.html`](../output/glimma-plots/ambiguous-enriched-clusters-8-md-plot.html).
</aside>

```{r ambiguous-enriched-clusters-8-md-plot, fig.cap = "Log-fold change in expression in the discarded cells compared to the retained cells. Each point represents a gene with mitochondrial transcripts in blue and ribosomal protein genes in orange. Dashed red lines indicate $|logFC| = 1$", fig.asp = 0.7}
is_mito <- rownames(sce) %in% mito_set
is_ribo <- rownames(sce) %in% ribo_set
plot(
  abundance,
  logFC,
  xlab = "Average count",
  ylab = "Log-FC (lost/kept)",
  pch = 16)
points(
  abundance[is_mito],
  logFC[is_mito],
  col = "dodgerblue",
  pch = 16,
  cex = 1)
points(
  abundance[is_ribo],
  logFC[is_ribo],
  col = "orange",
  pch = 16,
  cex = 1)
abline(h = c(-1, 1), col = "red", lty = 2)

glMDPlot(
  x = data.frame(abundance = abundance, logFC = logFC),
  xval = "abundance", 
  yval = "logFC",
  counts = cbind(lost, kept),
    anno = cbind(
      as.data.frame(rowData(sce)), 
      data.frame(GeneID = rownames(sce), stringsAsFactors = FALSE)),
  display.columns = c("Symbol", "ID", "CHR"),
  groups = factor(c("lost", "kept")),
  samples = c("lost", "kept"),
  status = unname(ifelse(is_mito, 1, ifelse(is_ribo, -1, 0))),
  transform = FALSE,
  main = "lost vs. kept",
  side.ylab = "Average count",
  cols = c("orange", "black", "dodgerBlue"),
  path = here("output"),
  html = "ambiguous-enriched-clusters-8-md-plot",
  launch = FALSE)
```

If the discarded pool is enriched for a certain cell type, we should observe increased expression of the corresponding marker genes.

Another concern is whether the cells removed by this procedure are preferentially derive from particular experimental groups.
Figure \@ref(fig:ambiguous-enriched-clusters-8-barplot-highlighting-removed-droplets) shows that excluding these droplets might preferentially exclude droplets from the `Uninfected` samples.

```{r ambiguous-enriched-clusters-8-barplot-highlighting-removed-droplets, fig.cap = "Droplets retained after excluding droplets from cluster 8, stratified by `Sample`."}
ggplot(
  data.frame(Sample = sce$Sample, keep = sce$cluster != "8")) + 
  geom_bar(aes(x = Sample, fill = keep)) + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 9) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

##### Cluster 9

```{r}
keep <- !sce$cluster == "9"
lost <- calculateAverage(counts(sce)[, !keep])
kept <- calculateAverage(counts(sce)[, keep])
logged <- cpm(cbind(lost, kept), log = TRUE, prior.count = 2)
logFC <- logged[, 1] - logged[, 2]
abundance <- rowMeans(logged)
```

Figure \@ref(fig:ambiguous-enriched-clusters-9-md-plot) shows the result of this analysis, highlighting that there are few genes with a large $logFC$ between 'lost' and 'kept' droplets.

<aside>
An interactive version of Figure \@ref(fig:ambiguous-enriched-clusters-9-md-plot) is available from [`output/glimma-plots/ambiguous-enriched-clusters-9-md-plot.html`](../output/glimma-plots/ambiguous-enriched-clusters-9-md-plot.html).
</aside>

```{r ambiguous-enriched-clusters-9-md-plot, fig.cap = "Log-fold change in expression in the discarded cells compared to the retained cells. Each point represents a gene with mitochondrial transcripts in blue and ribosomal protein genes in orange. Dashed red lines indicate $|logFC| = 1$", fig.asp = 0.7}
is_mito <- rownames(sce) %in% mito_set
is_ribo <- rownames(sce) %in% ribo_set
plot(
  abundance,
  logFC,
  xlab = "Average count",
  ylab = "Log-FC (lost/kept)",
  pch = 16)
points(
  abundance[is_mito],
  logFC[is_mito],
  col = "dodgerblue",
  pch = 16,
  cex = 1)
points(
  abundance[is_ribo],
  logFC[is_ribo],
  col = "orange",
  pch = 16,
  cex = 1)
abline(h = c(-1, 1), col = "red", lty = 2)

glMDPlot(
  x = data.frame(abundance = abundance, logFC = logFC),
  xval = "abundance", 
  yval = "logFC",
  counts = cbind(lost, kept),
    anno = cbind(
      as.data.frame(rowData(sce)), 
      data.frame(GeneID = rownames(sce), stringsAsFactors = FALSE)),
  display.columns = c("Symbol", "ID", "CHR"),
  groups = factor(c("lost", "kept")),
  samples = c("lost", "kept"),
  status = unname(ifelse(is_mito, 1, ifelse(is_ribo, -1, 0))),
  transform = FALSE,
  main = "lost vs. kept",
  side.ylab = "Average count",
  cols = c("orange", "black", "dodgerBlue"),
  path = here("output"),
  html = "ambiguous-enriched-clusters-9-md-plot",
  launch = FALSE)
```

If the discarded pool is enriched for a certain cell type, we should observe increased expression of the corresponding marker genes.

Another concern is whether the cells removed by this procedure are preferentially derive from particular experimental groups.
Reassuringly, Figure \@ref(fig:ambiguous-enriched-clusters-8-barplot-highlighting-removed-droplets) shows that this is not the case; most of the removed droplets are `ambiguous`, as we expect from the above analysis.

```{r ambiguous-enriched-clusters-10-barplot-highlighting-removed-droplets, fig.cap = "Droplets retained after excluding droplets from cluster 9, stratified by `Sample`."}
ggplot(
  data.frame(Sample = sce$Sample, keep = sce$cluster != "9")) + 
  geom_bar(aes(x = Sample, fill = keep)) + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 9) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### Summary 

```{r}
keep <- !sce$cluster %in% c("2", "7")
```

We conclude that droplets in clusters 2 and 7 do not contain intact cells, but rather comprises ambient RNA, and therefore remove all droplets in these clusters.
The removes `r sum(!keep)` droplets, retaining `r sum(keep)` for further analysis.
We do not exclude droplets from cluster 8 and 9 because these look to comprise some distinct cell type(s) that may be more prevalent in the `Uninfected` samples.

```{r}
sce <- sce[, keep]
colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")] <-
  droplevels(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")])
sample_colours <- sample_colours[levels(sce$Sample)]
treatment_colours <- treatment_colours[levels(sce$Treatment)]
```

### Re-processing

```{r}
var_fit <- modelGeneVarByPoisson(sce, block = sce$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)

set.seed(11235)
sce <- denoisePCA(
  sce, 
  var_fit, 
  subset.row = hvg,
  BSPARAM = BiocSingular::IrlbaParam(deferred = TRUE))

set.seed(8875)
sce <- runUMAP(sce, dimred = "PCA")
umap_df <- cbind(
  data.frame(
    x = reducedDim(sce, "UMAP")[, 1],
    y = reducedDim(sce, "UMAP")[, 2]),
  as.data.frame(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")]))

set.seed(8111)
# NOTE: k = 8 was chosen after some trial-and-error.
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA", k = 8)
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
umap_df$cluster <- sce$cluster
cluster_colours <- setNames(
  Polychrome::glasbey.colors(nlevels(sce$cluster) + 1)[-1],
  levels(sce$cluster))
sce$cluster_colours <- cluster_colours[sce$cluster]
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:no-ambiguous-enriched-clusters-clusterplot-umap) and broken down by experimental factors in Figure \@ref(fig:no-ambiguous-enriched-clusters-cluster-barplot).

```{r no-ambiguous-enriched-clusters-clusterplot-umap, fig.cap = "UMAP plot, where each point represents a droplet and is coloured according to the legend.", fig.asp = 0.7}
plot_grid(
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = cluster), size = 0.25) +
    scale_colour_manual(values = cluster_colours) + 
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2"),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Treatment), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = treatment_colours),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Sample), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = sample_colours),
  ncol = 2, 
  align = "v")
```

```{r no-ambiguous-enriched-clusters-cluster-barplot, fig.asp = 1 / 4, fig.cap = "Breakdown of clusters by experimental factors."}
plot_grid(
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Sample")])) + 
    geom_bar(
      aes(x = cluster, fill = Sample),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = sample_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Treatment")])) + 
    geom_bar(
      aes(x = cluster, fill = Treatment),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = treatment_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, "cluster", drop = FALSE])) + 
    geom_bar(aes(x = cluster, fill = cluster)) +
    coord_flip() +
    ylab("Number of droplets") +
    scale_fill_manual(values = cluster_colours) +
    theme_cowplot(font_size = 5) + 
    guides(fill = FALSE),
  align = "h",
  ncol = 3)
```

Notably:

- Still, some of the clusters are highly treatment-specific.
- **Still, some of the clusters are enriched for `ambiguous` droplets.**

We therefore repeat the process described in [First pass].

## Refinement

### Motivation

```{r, results = "hide"}
prop_ambiguous <- tapply(
  sce$Sample == "ambiguous",
  sce$cluster,
  function(x) sum(x) / length(x))
sort(prop_ambiguous)
prop_ambiguous_outliers <- isOutlier(
  prop_ambiguous,
  type = "higher",
  # NOTE: Want the cluster(s) that are **way** out there.
  nmads = 5)
ambiguous_enriched_clusters <- levels(sce$cluster)[prop_ambiguous_outliers]
stopifnot(identical(ambiguous_enriched_clusters, c("2", "8")))
```

There are still clusters with unusually large proportions of droplets being of `ambiguous` origin, namely clusters `r glue::glue_collapse(ambiguous_enriched_clusters, sep = " and ")` (proportions = `r glue::glue_collapse(round(prop_ambiguous[ambiguous_enriched_clusters], 2), " and ")`, respectively).

These droplets cannot be assigned to a sample of origin and so are not useful in downstream analyses.
However, before we exclude them, we want to ensure we aren't systematically excluding a biologically relevant cell population.

We would further like to know that this isn't systematically excluding droplets from a particular sample or treatment group.
This is challenging because by definition most of these droplets are of `ambiguous` origin.
However, we can check if the 'labelled' droplets in those clusters are enriched for particular samples.

### Analysis

Figure \@ref(fig:refined-ambiguous-enriched-clusters-umap) highlights droplets from these clusters on the UMAP plot, showing that they are largely distinct from the bulk of droplets from the dataset.

```{r refined-ambiguous-enriched-clusters-umap, fig.cap = "UMAP plot highlighting droplets from clusters that are enriched for `ambiguous` droplets. Cluster labels are overlaid on cluster centroids."}
plotUMAP(
  sce,
  colour_by = data.frame(
    `ambiguous enriched cluster` = sce$cluster %in% ambiguous_enriched_clusters),
  text_by = "cluster")
```

Figure \@ref(fig:refined-ambiguous-enriched-clusters-qc-plot) shows that the QC metrics of droplets from these clusters are distinct from the other clusters, having smaller library sizes and fewer genes detected (but no difference in mitochondrial proportions).

```{r refined-ambiguous-enriched-clusters-qc-plot, fig.cap = "QC metrics of droplets by cluster, highlighting droplets from clusters that are enriched for `ambiguous` droplets (orange)."}
plot_grid(
  plotColData(
    sce, 
    "sum", 
    x = "cluster", 
    colour_by = data.frame(
      `ambiguous enriched cluster` = 
        sce$cluster %in% ambiguous_enriched_clusters)) +
    scale_y_log10() + 
    guides(fill = FALSE),
  plotColData(
    sce, 
    "detected", 
    x = "cluster", 
    colour_by = data.frame(
      `ambiguous enriched cluster` = 
        sce$cluster %in% ambiguous_enriched_clusters)) +
    scale_y_log10() + 
    guides(fill = FALSE),
  plotColData(
  sce,
  "subsets_Mito_percent",
  x = "cluster",
  colour_by = data.frame(
      `ambiguous enriched cluster` = 
        sce$cluster %in% ambiguous_enriched_clusters)) + 
    guides(fill = FALSE),
  align = "v",
  ncol = 2)
```

Unlike in the [First pass], we have now clearly identified clusters of droplets that have abnormal QC metrics (rather than a mixture of abnormal and typical values).
Droplets with small library sizes are likely to contain ambient RNA rather than intact cells.

#### Checking for removal of biologically relevant subpopulations

We check for cell type loss by looking for systematic differences in gene expression between the discarded and retained droplets, doing this separately for each of the suspicious clusters.

##### Cluster 2

```{r}
keep <- !sce$cluster == "2"
lost <- calculateAverage(counts(sce)[, !keep])
kept <- calculateAverage(counts(sce)[, keep])
logged <- cpm(cbind(lost, kept), log = TRUE, prior.count = 2)
logFC <- logged[, 1] - logged[, 2]
abundance <- rowMeans(logged)
```

Figure \@ref(fig:refined-ambiguous-enriched-clusters-2-md-plot) shows the result of this analysis, highlighting that there are a few genes with a large $logFC$ between 'lost' and 'kept' droplets.

<aside>
An interactive version of Figure \@ref(fig:refined-ambiguous-enriched-clusters-2-md-plot) is available from [`output/glimma-plots/refined-ambiguous-enriched-clusters-2-md-plot.html`](../output/glimma-plots/refined-ambiguous-enriched-clusters-2-md-plot.html).
</aside>

```{r refined-ambiguous-enriched-clusters-2-md-plot, fig.cap = "Log-fold change in expression in the discarded cells compared to the retained cells. Each point represents a gene with mitochondrial transcripts in blue and ribosomal protein genes in orange. Dashed red lines indicate $|logFC| = 1$", fig.asp = 0.7}
is_mito <- rownames(sce) %in% mito_set
is_ribo <- rownames(sce) %in% ribo_set
plot(
  abundance,
  logFC,
  xlab = "Average count",
  ylab = "Log-FC (lost/kept)",
  pch = 16)
points(
  abundance[is_mito],
  logFC[is_mito],
  col = "dodgerblue",
  pch = 16,
  cex = 1)
points(
  abundance[is_ribo],
  logFC[is_ribo],
  col = "orange",
  pch = 16,
  cex = 1)
abline(h = c(-1, 1), col = "red", lty = 2)

glMDPlot(
  x = data.frame(abundance = abundance, logFC = logFC),
  xval = "abundance", 
  yval = "logFC",
  counts = cbind(lost, kept),
    anno = cbind(
      as.data.frame(rowData(sce)), 
      data.frame(GeneID = rownames(sce), stringsAsFactors = FALSE)),
  display.columns = c("Symbol", "ID", "CHR"),
  groups = factor(c("lost", "kept")),
  samples = c("lost", "kept"),
  status = unname(ifelse(is_mito, 1, ifelse(is_ribo, -1, 0))),
  transform = FALSE,
  main = "lost vs. kept",
  side.ylab = "Average count",
  cols = c("orange", "black", "dodgerBlue"),
  path = here("output"),
  html = "refined-ambiguous-enriched-clusters-2-md-plot",
  launch = FALSE)
```

If the discarded pool is enriched for a certain cell type, we should observe increased expression of the corresponding marker genes.
Although there is a subset of genes with large $logFC$, Figure \@ref(fig:refined-ambiguous-enriched-clusters-2-markers) shows that these same genes are expressed in other clusters which means that we are unlikely to be systematically excluding a biologically relevant population of cells.

```{r refined-ambiguous-enriched-clusters-2-markers, fig.cap = "Expression of genes with top-9 largest $|logFC|$ when comparing the the discarded cells to the retained cell. Each of these genes is expressed at a higher (or comparable) level in droplets from at least one of the retained clusters."}
plotExpression(
  sce,
  names(sort(logFC, decreasing = TRUE))[1:9],
  x = "cluster",
  colour_by = data.frame(
    `ambiguous enriched cluster` = 
      sce$cluster %in% ambiguous_enriched_clusters),
  ncol = 3) +
  guides(fill = FALSE)
```

Another concern is whether the cells removed by this procedure are preferentially derive from particular experimental groups.
Reassuringly, Figure \@ref(fig:refined-ambiguous-enriched-clusters-2-barplot-highlighting-removed-droplets) shows that this is not the case; most of the removed droplets are `ambiguous`, as we expect from the above analysis.

```{r refined-ambiguous-enriched-clusters-2-barplot-highlighting-removed-droplets, fig.cap = "Droplets retained after excluding droplets from cluster 2, stratified by `Sample`."}
ggplot(
  data.frame(Sample = sce$Sample, keep = sce$cluster != "2")) + 
  geom_bar(aes(x = Sample, fill = keep)) + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 9) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

##### Cluster 8

```{r}
keep <- !sce$cluster == "8"
lost <- calculateAverage(counts(sce)[, !keep])
kept <- calculateAverage(counts(sce)[, keep])
logged <- cpm(cbind(lost, kept), log = TRUE, prior.count = 2)
logFC <- logged[, 1] - logged[, 2]
abundance <- rowMeans(logged)
```

Figure \@ref(fig:refined-ambiguous-enriched-clusters-8-md-plot) shows the result of this analysis, highlighting that there are few genes with a large $logFC$ between 'lost' and 'kept' droplets and that the systematically downregulated genes are largely ribosomal protein genes.

<aside>
An interactive version of Figure \@ref(fig:refined-ambiguous-enriched-clusters-8-md-plot) is available from [`output/glimma-plots/refined-ambiguous-enriched-clusters-8-md-plot.html`](../output/glimma-plots/refined-ambiguous-enriched-clusters-8-md-plot.html).
</aside>

```{r refined-ambiguous-enriched-clusters-8-md-plot, fig.cap = "Log-fold change in expression in the discarded cells compared to the retained cells. Each point represents a gene with mitochondrial transcripts in blue and ribosomal protein genes in orange. Dashed red lines indicate $|logFC| = 1$", fig.asp = 0.7}
is_mito <- rownames(sce) %in% mito_set
is_ribo <- rownames(sce) %in% ribo_set
plot(
  abundance,
  logFC,
  xlab = "Average count",
  ylab = "Log-FC (lost/kept)",
  pch = 16)
points(
  abundance[is_mito],
  logFC[is_mito],
  col = "dodgerblue",
  pch = 16,
  cex = 1)
points(
  abundance[is_ribo],
  logFC[is_ribo],
  col = "orange",
  pch = 16,
  cex = 1)
abline(h = c(-1, 1), col = "red", lty = 2)

glMDPlot(
  x = data.frame(abundance = abundance, logFC = logFC),
  xval = "abundance", 
  yval = "logFC",
  counts = cbind(lost, kept),
    anno = cbind(
      as.data.frame(rowData(sce)), 
      data.frame(GeneID = rownames(sce), stringsAsFactors = FALSE)),
  display.columns = c("Symbol", "ID", "CHR"),
  groups = factor(c("lost", "kept")),
  samples = c("lost", "kept"),
  status = unname(ifelse(is_mito, 1, ifelse(is_ribo, -1, 0))),
  transform = FALSE,
  main = "lost vs. kept",
  side.ylab = "Average count",
  cols = c("orange", "black", "dodgerBlue"),
  path = here("output"),
  html = "refined-ambiguous-enriched-clusters-8-md-plot",
  launch = FALSE)
```

If the discarded pool is enriched for a certain cell type, we should observe increased expression of the corresponding marker genes.
Although there is a subset of genes with large $logFC$, Figure \@ref(fig:refined-ambiguous-enriched-clusters-8-markers) shows that these same genes are expressed in other clusters which means that we are unlikely to be systematically excluding a biologically relevant population of cells.

```{r refined-ambiguous-enriched-clusters-8-markers, fig.cap = "Expression of genes with top-9 largest $|logFC|$ when comparing the the discarded cells to the retained cell. Each of these genes is expressed at a higher (or comparable) level in droplets from at least one of the retained clusters."}
plotExpression(
  sce,
  names(sort(logFC, decreasing = TRUE))[1:9],
  x = "cluster",
  colour_by = data.frame(
    `ambiguous enriched cluster` = 
      sce$cluster %in% ambiguous_enriched_clusters),
  ncol = 3) +
  guides(fill = FALSE)
```

Another concern is whether the cells removed by this procedure are preferentially derive from particular experimental groups.
Reassuringly, Figure \@ref(fig:refined-ambiguous-enriched-clusters-8-barplot-highlighting-removed-droplets) shows that this is not the case; most of the removed droplets are `ambiguous`, as we expect from the above analysis.

```{r refined-ambiguous-enriched-clusters-8-barplot-highlighting-removed-droplets, fig.cap = "Droplets retained after excluding droplets from cluster 8, stratified by `Sample`."}
ggplot(
  data.frame(Sample = sce$Sample, keep = sce$cluster != "8")) + 
  geom_bar(aes(x = Sample, fill = keep)) + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 9) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### Summary

```{r}
keep <- !sce$cluster %in% c("2", "8")
```
We conclude that droplets in clusters 2 and 8 do not contain intact cells, but rather comprises ambient RNA, and therefore remove all droplets in these clusters.
The removes `r sum(!keep)` droplets, retaining `r sum(keep)` for further analysis.

```{r}
sce <- sce[, keep]
colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")] <-
  droplevels(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")])
sample_colours <- sample_colours[levels(sce$Sample)]
treatment_colours <- treatment_colours[levels(sce$Treatment)]
```

### Re-processing

```{r}
var_fit <- modelGeneVarByPoisson(sce, block = sce$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)

set.seed(11235)
sce <- denoisePCA(
  sce, 
  var_fit, 
  subset.row = hvg,
  BSPARAM = BiocSingular::IrlbaParam(deferred = TRUE))

set.seed(8875)
sce <- runUMAP(sce, dimred = "PCA")
umap_df <- cbind(
  data.frame(
    x = reducedDim(sce, "UMAP")[, 1],
    y = reducedDim(sce, "UMAP")[, 2]),
  as.data.frame(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")]))

set.seed(8111)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
umap_df$cluster <- sce$cluster
cluster_colours <- setNames(
  Polychrome::glasbey.colors(nlevels(sce$cluster) + 1)[-1],
  levels(sce$cluster))
sce$cluster_colours <- cluster_colours[sce$cluster]
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:no-refined-ambiguous-enriched-clusters-clusterplot-umap) and broken down by experimental factors in Figure \@ref(fig:no-refined-ambiguous-enriched-clusters-cluster-barplot).

```{r no-refined-ambiguous-enriched-clusters-clusterplot-umap, fig.cap = "UMAP plot, where each point represents a droplet and is coloured according to the legend.", fig.asp = 0.7}
plot_grid(
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = cluster), size = 0.25) +
    scale_colour_manual(values = cluster_colours) + 
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2"),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Treatment), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = treatment_colours),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Sample), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = sample_colours),
  ncol = 2, 
  align = "v")
```

```{r no-refined-ambiguous-enriched-clusters-cluster-barplot, fig.asp = 1 / 4, fig.cap = "Breakdown of clusters by experimental factors."}
plot_grid(
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Sample")])) + 
    geom_bar(
      aes(x = cluster, fill = Sample),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = sample_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Treatment")])) + 
    geom_bar(
      aes(x = cluster, fill = Treatment),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = treatment_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, "cluster", drop = FALSE])) + 
    geom_bar(aes(x = cluster, fill = cluster)) +
    coord_flip() +
    ylab("Number of droplets") +
    scale_fill_manual(values = cluster_colours) +
    theme_cowplot(font_size = 5) + 
    guides(fill = FALSE),
  align = "h",
  ncol = 3)
```

Notably:

- Still, some of the clusters are highly treatment-specific.
- **Now, none of the clusters are enriched for `ambiguous` droplets.**

# Doublets

## Motivation

For multiplexed samples such as these, we can identify (most of) the doublet cells based on the droplets that have multiple labels.
The idea here is that cells from the same sample are labelled in a unique manner and that cells from all samples are then mixed together and the multiplexed pool is subjected to scRNA-seq, avoiding batch effects and simplifying the logistics of processing a large number of samples.
Moreover, most per-cell libraries are expected to contain one label that can be used to assign that cell to its sample of origin.
Cell libraries containing two labels are thus likely to be doublets of cells from different samples.

## Analysis

We first use the HTOs to identify 'labelled' doublets and then leverage these in to identify 'unlabelled' doublets in the gene expression space.

### 'Labelled' doublets

For this experiment, the sample labelling is done with HTOs.
With 5 unique HTOs, there are ${5 \choose 2} = 10$ ways a droplet could be labelled with 2 HTOs.
The cell hashing data will not identify all doublets, most obviously those formed between cells from the same sample.
It will also be near impossible to identify those doublets formed between a cell labelled with all 5 HTOs (i.e. a cell from the `uninfected_3` sample) and another cell labelled with a single HTO.

We can easily identify the HTO-derived doublets (droplets with `Sample` labelled as `doublet`; n = `r sum(sce$Sample == "doublet")`, `r round(100 * sum(sce$Sample == "doublet") / ncol(sce), 1)`% of remaining droplets).
We term these the 'labelled' droplets.

### 'Unlabelled' dropets

One obvious limitation of relying solely on the HTO-derived doublets is that doublets of cells marked with the same HTO or those doublets formed between a cell labelled with all 5 HTOs (i.e. a cell from the `uninfected_3` sample) and another cell labelled with a single HTO are not detected^[In a simple multiplexing experiment involving $N$ HTOs (here $N=5$) with similar numbers of cells, we would expect around $1 / N = 1 / 5 = 20\%$ of all doublets to involve cells from the same sample. This may still be enough to cause the formation of misleading doublet clusters even after the majority of 'labelled' doublets are removed.].

To avoid this, we recover the remaining intra-sample doublets based on their similarity with 'known' doublets in gene expression space, i.e. 'guilt by association'.

For each droplet, we calculate the proportion of its nearest neighbours that are 'labelled' doublets^[The use of experimentally derived doublet calls avoids any assumptions about the relative quantity of total RNA or the probability of doublet formation across different cell types.].
Intra-sample doublets should have values of this metric under the assumption that their gene expression profiles are similar to inter-sample doublets involving the same combination of cell states/types.

```{r}
# NOTE: This is a hack to estimate the relative frequency of each 
#       (labelled singlet) sample.
sample_freq <- table(sce$Sample)[
  c(paste0("infected_", 1:3), paste0("uninfected_", 1:3))]
doublets_df <- doubletRecovery(
  sce,
  doublets = sce$Sample == "doublet",
  use.dimred = "PCA",
  samples = sample_freq)
```

Figure \@ref(fig:doublet-umap) highlights the location of 'labelled' doublets and those predicted to be doublets on the UMAP plot.

```{r doublet-umap, fig.asp = 1 / 3, fig.cap = "UMAP plot, where each point is a cell and is colored by the whether or not it is a 'labelled' doublet (left), by the proportion of neighbouring droplets that are 'labelled' droplets (centre), and whether or not it is a predicted 'unlabelled' doublet (right)."}
umap_df$known_doublet_proportion <- doublets_df$proportion
umap_df$known_doublet <- doublets_df$known
umap_df$predicted_doublet <- doublets_df$predicted
plot_grid(
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(
      aes(
        colour = known_doublet,
        alpha = known_doublet,
        size = known_doublet)) +
    scale_colour_manual(values = c("FALSE" = "grey", "TRUE" = "red")) +
    scale_alpha_manual(values = c("FALSE" = 0.25, "TRUE" = 1)) +
    scale_size_manual(values = c("FALSE" = 0.125, "TRUE" = 0.25)) +
    theme_cowplot(font_size = 8) +
    xlab("Dimension 1") +
    ylab("Dimension 2") +
    guides(colour = FALSE, size = FALSE, alpha = FALSE) + 
    ggtitle("Known doublets"),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = known_doublet_proportion), size = 0.125) +
    theme_cowplot(font_size = 8) +
    xlab("Dimension 1") +
    ylab("Dimension 2") +
    scale_colour_viridis_c(guide = guide_colorbar("")) + 
    ggtitle("Doublet proportions") + 
    theme(legend.position = c(0.9, 0.9)),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(
      aes(
        colour = predicted_doublet,
        alpha = predicted_doublet,
        size = predicted_doublet)) +
    scale_colour_manual(values = c("FALSE" = "grey", "TRUE" = "royalblue")) +
    scale_alpha_manual(values = c("FALSE" = 0.25, "TRUE" = 1)) +
    scale_size_manual(values = c("FALSE" = 0.125, "TRUE" = 0.25)) +
    theme_cowplot(font_size = 8) +
    xlab("Dimension 1") +
    ylab("Dimension 2") +
    guides(colour = FALSE, size = FALSE, alpha = FALSE) + 
    ggtitle("Predicted doublets"),
  align = "v",
  ncol = 3)
```

Reassuringly, most of the 'unlabelled' doublets come from the droplets currently labelled as originating from the `uninfected_3` sample, which was labelled with all 5 HTOs, or the `ambiguous` sample, for bth of which it was difficult to identify 'labelled' doublets.

```{r}
library(janitor)
tabyl(
  data.frame(predicted_doublet = doublets_df$predicted, Sample = sce$Sample),
  Sample, predicted_doublet) %>%
  adorn_totals(c("row", "col")) %>%
  adorn_percentages("row") %>%
  adorn_pct_formatting() %>%
  adorn_ns() %>%
  adorn_title(placement = "combined") %>%
  knitr::kable(caption = "Number of predicted 'unlabelled' doublets (`TRUE` column) that were labelled as coming from each `Sample`. Percentages are with respect to the total number of droplets from eahc `Sample`.")
```

### Checking for removal of biologically relevant subpopulations

We again check for cell type loss by looking for systematic differences in gene expression between the discarded and retained cells.

```{r}
keep <- !(doublets_df$known | doublets_df$predicted)
lost <- calculateAverage(counts(sce)[, !keep])
kept <- calculateAverage(counts(sce)[, keep])
logged <- cpm(cbind(lost, kept), log = TRUE, prior.count = 2)
logFC <- logged[, 1] - logged[, 2]
abundance <- rowMeans(logged)
```

Figure \@ref(fig:doublet-md-plot) shows the result of this analysis, highlighting that there are few genes with a large $logFC$ between 'lost' and 'kept' droplets.

<aside>
An interactive version of Figure \@ref(fig:doublet-md-plot) is available from [`output/glimma-plots/doublet-md-plot.html`](../output/glimma-plots/doublet-md-plot.html).
</aside>

```{r doublet-md-plot, fig.cap = "Log-fold change in expression in the discarded cells compared to the retained cells. Each point represents a gene with mitochondrial transcripts in blue and ribosomal protein genes in orange. Dashed red lines indicate $|logFC| = 1$", fig.asp = 0.7}
is_mito <- rownames(sce) %in% mito_set
is_ribo <- rownames(sce) %in% ribo_set
plot(
  abundance,
  logFC,
  xlab = "Average count",
  ylab = "Log-FC (lost/kept)",
  pch = 16)
points(
  abundance[is_mito],
  logFC[is_mito],
  col = "dodgerblue",
  pch = 16,
  cex = 1)
points(
  abundance[is_ribo],
  logFC[is_ribo],
  col = "orange",
  pch = 16,
  cex = 1)
abline(h = c(-1, 1), col = "red", lty = 2)

glMDPlot(
  x = data.frame(abundance = abundance, logFC = logFC),
  xval = "abundance", 
  yval = "logFC",
  counts = cbind(lost, kept),
    anno = cbind(
      as.data.frame(rowData(sce)), 
      data.frame(GeneID = rownames(sce), stringsAsFactors = FALSE)),
  display.columns = c("Symbol", "ID", "CHR"),
  groups = factor(c("lost", "kept")),
  samples = c("lost", "kept"),
  status = unname(ifelse(is_mito, 1, ifelse(is_ribo, -1, 0))),
  transform = FALSE,
  main = "lost vs. kept",
  side.ylab = "Average count",
  cols = c("orange", "black", "dodgerBlue"),
  path = here("output"),
  html = "doublet-md-plot",
  launch = FALSE)
```

If the discarded pool is enriched for a certain cell type, we should observe increased expression of the corresponding marker genes.

Another concern is whether the cells removed by this procedure are preferentially derive from particular experimental groups.
Reassuringly, Figure \@ref(fig:doublet-barplot-highlighting-removed-droplets) shows that this is not the case; most of the removed droplets are 'labelled' doublets, as we expect from the above analysis.

```{r doublet-barplot-highlighting-removed-droplets, fig.cap = "Droplets removed after excluding 'labelled' and 'unlabelled' predicted doublets, stratified by `Sample`."}
ggplot(
  data.frame(Sample = sce$Sample, keep = keep)) + 
  geom_bar(aes(x = Sample, fill = keep)) + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 9) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### Summary 

```{r}
sce <- sce[, keep]
```

We opt to remove both the 'labelled' known doublets and 'unlabelled' predicted doublets from the dataset.
The removes `r sum(!keep)` droplets, retaining `r sum(keep)` for further analysis.
The dataset may still contain some 'unlabelled' doublets, but their number should be very small owing to the experimental design.

```{r}
colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")] <-
  droplevels(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")])
sample_colours <- sample_colours[levels(sce$Sample)]
treatment_colours <- treatment_colours[levels(sce$Treatment)]
```

## Re-processing

```{r}
var_fit <- modelGeneVarByPoisson(sce, block = sce$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)

set.seed(11235)
sce <- denoisePCA(
  sce, 
  var_fit, 
  subset.row = hvg,
  BSPARAM = BiocSingular::IrlbaParam(deferred = TRUE))

set.seed(8875)
sce <- runUMAP(sce, dimred = "PCA")
umap_df <- cbind(
  data.frame(
    x = reducedDim(sce, "UMAP")[, 1],
    y = reducedDim(sce, "UMAP")[, 2]),
  as.data.frame(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")]))

set.seed(8111)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
umap_df$cluster <- sce$cluster
cluster_colours <- setNames(
  Polychrome::glasbey.colors(nlevels(sce$cluster) + 1)[-1],
  levels(sce$cluster))
sce$cluster_colours <- cluster_colours[sce$cluster]
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:no-doublets-clusterplot-umap-clusterplot-umap) and broken down by experimental factors in Figure \@ref(fig:no-doublets-clusterplot-umap-cluster-barplot).

```{r no-doublets-clusterplot-umap-clusterplot-umap, fig.cap = "UMAP plot, where each point represents a droplet and is coloured according to the legend.", fig.asp = 0.7}
plot_grid(
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = cluster), size = 0.25) +
    scale_colour_manual(values = cluster_colours) + 
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2"),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Treatment), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = treatment_colours),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Sample), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = sample_colours),
  ncol = 2, 
  align = "v")
```

```{r no-doublets-clusterplot-umap-cluster-barplot, fig.asp = 1 / 4, fig.cap = "Breakdown of clusters by experimental factors."}
plot_grid(
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Sample")])) + 
    geom_bar(
      aes(x = cluster, fill = Sample),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = sample_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Treatment")])) + 
    geom_bar(
      aes(x = cluster, fill = Treatment),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = treatment_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, "cluster", drop = FALSE])) + 
    geom_bar(aes(x = cluster, fill = cluster)) +
    coord_flip() +
    ylab("Number of droplets") +
    scale_fill_manual(values = cluster_colours) +
    theme_cowplot(font_size = 5) + 
    guides(fill = FALSE),
  align = "h",
  ncol = 3)
```

Notably:

- Still, some of the clusters are highly treatment-specific.
- Still, none of the clusters are enriched for `ambiguous` droplets.
- **Now, none of the clusters are highly sample-specific.**

# Selection of 'labelled' singlets

## Motivation

```{r, results = "hide"}
prop_ambiguous <- tapply(
  sce$Sample == "ambiguous",
  sce$cluster,
  function(x) sum(x) / length(x))
sort(prop_ambiguous)
prop_ambiguous_outliers <- isOutlier(
  prop_ambiguous,
  type = "higher",
  # NOTE: Want the cluster(s) that are **way** out there.
  nmads = 5)
ambiguous_enriched_clusters <- levels(sce$cluster)[prop_ambiguous_outliers]
stopifnot(identical(ambiguous_enriched_clusters, character(0)))
```

There is no cluster with a notably large number of `ambiguous` droplets.
If there were, our concern would be that this could indicate a cell subpopulation (e.g., cell type) that is systematically failing to be labelled by one or more of the HTOs.

## Analysis

Since there are no clusters enriched for `ambiguous` droplets, there is no cluster-level analysis to be performed.
Instead, we simply remove the droplets labelled as `ambiguous`.

### Checking for removal of biologically relevant subpopulations

We again check for cell type loss by looking for systematic differences in gene expression between the discarded and retained cells.

```{r}
keep <- sce$Sample != "ambiguous"
lost <- calculateAverage(counts(sce)[, !keep])
kept <- calculateAverage(counts(sce)[, keep])
logged <- cpm(cbind(lost, kept), log = TRUE, prior.count = 2)
logFC <- logged[, 1] - logged[, 2]
abundance <- rowMeans(logged)
```

Figure \@ref(fig:labelled-singlets-md-plot) shows the result of this analysis, highlighting that there are few genes with a large $logFC$ between 'lost' and 'kept' droplets.

<aside>
An interactive version of Figure \@ref(fig:labelled-singlets-md-plot) is available from [`output/glimma-plots/labelled-singlets-md-plot.html`](../output/glimma-plots/labelled-singlets-md-plot.html).
</aside>

```{r labelled-singlets-md-plot, fig.cap = "Log-fold change in expression in the discarded cells compared to the retained cells. Each point represents a gene with mitochondrial transcripts in blue and ribosomal protein genes in orange. Dashed red lines indicate $|logFC| = 1$", fig.asp = 0.7}
is_mito <- rownames(sce) %in% mito_set
is_ribo <- rownames(sce) %in% ribo_set
plot(
  abundance,
  logFC,
  xlab = "Average count",
  ylab = "Log-FC (lost/kept)",
  pch = 16)
points(
  abundance[is_mito],
  logFC[is_mito],
  col = "dodgerblue",
  pch = 16,
  cex = 1)
points(
  abundance[is_ribo],
  logFC[is_ribo],
  col = "orange",
  pch = 16,
  cex = 1)
abline(h = c(-1, 1), col = "red", lty = 2)

glMDPlot(
  x = data.frame(abundance = abundance, logFC = logFC),
  xval = "abundance", 
  yval = "logFC",
  counts = cbind(lost, kept),
    anno = cbind(
      as.data.frame(rowData(sce)), 
      data.frame(GeneID = rownames(sce), stringsAsFactors = FALSE)),
  display.columns = c("Symbol", "ID", "CHR"),
  groups = factor(c("lost", "kept")),
  samples = c("lost", "kept"),
  status = unname(ifelse(is_mito, 1, ifelse(is_ribo, -1, 0))),
  transform = FALSE,
  main = "lost vs. kept",
  side.ylab = "Average count",
  cols = c("orange", "black", "dodgerBlue"),
  path = here("output"),
  html = "labelled-singlets-md-plot",
  launch = FALSE)
```

If the discarded pool is enriched for a certain cell type, we should observe increased expression of the corresponding marker genes.

Another concern is whether the cells removed by this procedure are preferentially derive from particular experimental groups.
Reassuringly, Figure \@ref(fig:labelled-singlets-barplot-highlighting-removed-droplets) shows that this is not the case; all of the removed droplets are `ambiguous` droplets, as we expect from the above analysis.

```{r labelled-singlets-barplot-highlighting-removed-droplets, fig.cap = "Droplets removed after excluding `Negative` and `unassigned` droplets, stratified by `Sample`."}
ggplot(
  data.frame(Sample = sce$Sample, keep = keep)) + 
  geom_bar(aes(x = Sample, fill = keep)) + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 9) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Summary

We can conclude that it is unlikely that our HTO labelling has systematically under-labelled a biologically relevant cell type.
Furthermore, the `ambiguous` droplets are not useful in downstream analyses because we cannot match them to a treatment, and so we removed all `ambiguous` droplets from the data.
The removes `r sum(!keep)` droplets, retaining `r sum(keep)` for further analysis.

At this point, our dataset only contains 'labelled' singlets, i.e. those droplets we are confident are single cells and that we can assign to a single sample.
These are the cells we want to use in our downstream analysis.

```{r}
sce <- sce[, keep]
colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")] <-
  droplevels(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")])
sample_colours <- sample_colours[levels(sce$Sample)]
treatment_colours <- treatment_colours[levels(sce$Treatment)]
```

## Re-processing

```{r}
var_fit <- modelGeneVarByPoisson(sce, block = sce$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)

set.seed(11235)
sce <- denoisePCA(
  sce, 
  var_fit, 
  subset.row = hvg,
  BSPARAM = BiocSingular::IrlbaParam(deferred = TRUE))

set.seed(8875)
sce <- runUMAP(sce, dimred = "PCA")
umap_df <- cbind(
  data.frame(
    x = reducedDim(sce, "UMAP")[, 1],
    y = reducedDim(sce, "UMAP")[, 2]),
  as.data.frame(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")]))

set.seed(8111)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
umap_df$cluster <- sce$cluster
cluster_colours <- setNames(
  Polychrome::glasbey.colors(nlevels(sce$cluster) + 1)[-1],
  levels(sce$cluster))
sce$cluster_colours <- cluster_colours[sce$cluster]
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:labelled-singlets-clusterplot-umap) and broken down by experimental factors in Figure \@ref(fig:labelled-singlets-cluster-barplot).

```{r labelled-singlets-clusterplot-umap, fig.cap = "UMAP plot of the updated data, where each point represents a droplet and is coloured according to the legend.", fig.asp = 0.7}
plot_grid(
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = cluster), size = 0.25) +
    scale_colour_manual(values = cluster_colours) + 
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2"),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Treatment), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = treatment_colours),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Sample), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = sample_colours),
  ncol = 2, 
  align = "v")
```

```{r labelled-singlets-cluster-barplot, fig.asp = 1 / 4, fig.cap = "Breakdown of clusters by experimental factors."}
plot_grid(
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Sample")])) + 
    geom_bar(
      aes(x = cluster, fill = Sample),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = sample_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Treatment")])) + 
    geom_bar(
      aes(x = cluster, fill = Treatment),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = treatment_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, "cluster", drop = FALSE])) + 
    geom_bar(aes(x = cluster, fill = cluster)) +
    coord_flip() +
    ylab("Number of droplets") +
    scale_fill_manual(values = cluster_colours) +
    theme_cowplot(font_size = 5) + 
    guides(fill = FALSE),
  align = "h",
  ncol = 3)
```

Notably:

- Still, some of the clusters are highly treatment-specific.
- Still, none of the clusters are highly sample-specific.

# Exclusion of unwanted cell types

## Motivation

James enriched for CD4+ T-cells prior to performing scRNA-seq.
However, an enrichment procedure is just that and unwanted cell types may sneak through.

We can categorise unwanted cell types as either:

1. 'Known' unwanted cell types: Unwanted cell types that we did know to look for *a priori* (i.e. unwanted cell types we know may have snuck through the enrichment process)
2. 'ambiguous' unwanted cell types: Unwanted cell types that we didn't know to look for *a priori* (i.e. unwanted cell types that we didn't may have snuck through the enrichment process).

We will use different analysis strategies to identify the 'known' and 'unknown' unwanted cell types.
Once we have identified the unwanted cell types, we will exclude the unwanted these cells from further analysis.

## 'Unknown' unwanted cell types

### Motivation

A conceptually straightforward annotation approach is to compare the single-cell expression profiles with previously annotated reference data sets.
Labels can then be assigned to each cell in our uncharacterised test data set based on the most similar reference sample(s), for some definition of "similar".
Any published and labelled RNA-seq data set (bulk or single-cell) can be used as a reference, though its reliability depends greatly on the expertise of the original authors who assigned the labels in the first place.

`r BiocStyle::Biocpkg("SingleR")` is one such automatic annotation method for scRNA-seq data [@aran2019reference].
Given a reference data set(s) of samples^[This can be individual cells or bulk samples.] with known labels, it labels new cells from a test data set based on similarity to the reference set(s).
Specifically, for each test cell:

1. We compute the Spearman correlation between its expression profile and that of each reference sample. 
2. We define the per-label score as a fixed quantile (by default, 0.8) of the distribution of correlations.
3. We repeat this for all labels and we take the label with the highest score as the annotation for this cell.
4. Finally, we perform a fine-tuning step:
- The reference data set is subsetted to only include labels with scores close to the maximum.
- Scores are recomputed using only marker genes for the subset of labels.
- This is iterated until one label remains.

For visualization purposes we use the normalized scores, which are the scores linearly adjusted for each cell so that the smallest score is 0 and the largest score is 1.
This is followed by cubing of the adjusted scores to improve dynamic range near 1. 

Automatic annotation provides a convenient way of transferring biological knowledge across data sets.
In this manner, the burden of interpreting clusters and defining marker genes only has to be done once (i.e. for the reference set).

`r BiocStyle::Biocpkg("SingleR")` can annotate at both the cluster-level and at the cell-level.
The trade-off between cluster-level and cell-level annotation is one of increased robustness to noise (cluster-level) vs. increased resolution (cell-level).
Poor-quality assignments with 'low' scores are labelled as `NA`.

#### Available references

`r BiocStyle::Biocpkg("SingleR")` includes several in-built reference data sets, some of which are relevant for this study:

* `HumanPrimaryCellAtlasData` (`HPCA`): The Human Primary Cell Atlas [@hpcaRef]
* `BlueprintEncodeData` (`BE`): Blueprint [@blueprintRef] and Encode [@encodeRef]
* `DatabaseImmuneCellExpressionData` (`DICE`): The [Database of Immune Cell Expression (DICE)](https://dice-database.org/) [@diceRef]
* `NovershternHematopoieticData` (`NH`): The [Novershtern Hematopoietic Cell Data (GSE24759)](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE24759) [@nhRef]
* `MonacoImmuneData` (`MI`): The [Monaco Immune Cell Data (GSE107011)](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE107011) [@monaco_immuneRef].

These bulk RNA-seq and microarray data sets were obtained from pre-sorted cell populations, i.e., the cell labels of these samples were mostly derived based on the respective sorting/purification strategy, not via *in silico* prediction methods.

The characteristics of each data set are summarized below^[Table adapted from [https://bioconductor.org/packages/release/bioc/vignettes/SingleR/inst/doc/SingleR.html#5_available_references](https://bioconductor.org/packages/release/bioc/vignettes/SingleR/inst/doc/SingleR.html#5_available_references)]:

| Reference | Samples | Sample types |  No. of main labels  | No. of fine labels | Cell type focus |
|------------------|----------|-------------|----------------------|------------|----------|
|`HPCA`| 713 | microarrays of sorted cell populations  | 37 |  157 | Non-specific |
|`BE` | 259 | RNA-seq | 24 | 43 | Non-specific |
|`DICE` | 1561 | RNA-seq | 5 | 15 | Immune |
|`NH` | 211 | microarrays of sorted cell populations | 17 | 38 | Hematopoietic & Immune |
|`MI` | 114 | RNA-seq | 11 | 29 | Immune |

The available sample types in each set can be viewed in the collapsible sections below.

```{r}
library(SingleR)
```

<details>
<summary>`HumanPrimaryCellAtlasData` Labels</summary>

```{r, echo=FALSE, message=FALSE}
hpca <- HumanPrimaryCellAtlasData()
.adf(colData(hpca)) %>% 
  dplyr::count(label.main, label.fine) %>%
  dplyr::arrange(label.main) %>%
  knitr::kable()
```
</details>

<details>
<summary>`BlueprintEncodeData` Labels</summary>

```{r, echo = FALSE, message = FALSE}
be <- BlueprintEncodeData()
.adf(colData(be)) %>% 
  dplyr::count(label.main, label.fine) %>%
  dplyr::arrange(label.main) %>%
  knitr::kable()
```
</details>

<details>
<summary>`DatabaseImmuneCellExpressionData` Labels</summary>

```{r, echo = FALSE, message = FALSE}
dice <- DatabaseImmuneCellExpressionData()
.adf(colData(dice)) %>% 
  dplyr::count(label.main, label.fine) %>%
  dplyr::arrange(label.main) %>%
  knitr::kable()
```
</details>

<details>
<summary>`MonacoImmuneData` Labels</summary>

```{r, echo = FALSE, message = FALSE}
mi <- MonacoImmuneData()
.adf(colData(mi)) %>% 
  dplyr::count(label.main, label.fine) %>%
  dplyr::arrange(label.main) %>%
  knitr::kable()
```
</details>

<details>
<summary>`NovershternHematopoieticData` Labels</summary>

```{r, echo = FALSE, message = FALSE}
nh <- NovershternHematopoieticData()
.adf(colData(nh)) %>% 
  dplyr::count(label.main, label.fine) %>%
  dplyr::arrange(label.main) %>%
  knitr::kable()
```
</details>

### Analysis

For simplicity, I have opted to only use the 'main' labels from the `DICE` reference annotation and annotated the dataset at the cluster-level.
The 'main' labels provide broad cell type labels appropriate for identifying clusters of an 'unwanted' cell type.

<aside>
This reference was recommended to me by colleagues with experience in using `r BiocStyle::Biocpkg("SingleR")` to annotate T-cells profiled with scRNA-seq.
</aside>

```{r}
ref <- dice
labels_main <- ref$label.main
# NOTE: This code doesn't necessarily generalise beyond the DICE main labels.
label_main_collapsed_colours <- setNames(
  c(
    Polychrome::glasbey.colors(nlevels(factor(labels_main)) + 1)[-1],
    "orange"),
  c(levels(factor(labels_main)), "other"))
```

```{r}
pred_cluster_main <- SingleR(
  test = sce,
  ref = ref,
  labels = labels_main,
  method = "cluster",
  cluster = sce$cluster,
  BPPARAM = bpparam())

sce$label_cluster_main <- factor(pred_cluster_main$pruned.labels[sce$cluster])
sce$label_cluster_main_collapsed <- .collapseLabel(
  sce$label_cluster_main,
  sce$batch)
sce$label_main_collapsed_colours <- label_main_collapsed_colours[
  as.character(sce$label_cluster_main)]
umap_df$label_cluster_main_collapsed <- sce$label_cluster_main_collapsed
```

The results are summarised in the table below.

```{r}
tabyl(
  data.frame(label.main = sce$label_cluster_main, cluster = sce$cluster), 
  cluster, 
  label.main) %>%
  knitr::kable(
    caption = "Cluster-level assignments using the main labels of the DICE reference.")
```

Figure \@ref(fig:umap-with-main-cluster-labels) overlays these cell type labels on the UMAP plot and shows that the aforementioned small, distinct cluster is labelled as `Monocytes`.

```{r umap-with-main-cluster-labels, fig.asp = 1 / 3, fig.cap = "UMAP plot highlighting clusters (left) and 'main' cluster-level labels (right) where each panel highlights droplets from a particular label. Labels with < 1% frequency are grouped together as `other`."}
p1 <- ggplot(aes(x = x, y = y), data = umap_df) +
  geom_point(
    aes(colour = cluster),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = cluster_colours) +
  scale_colour_manual(values = cluster_colours) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  ggtitle("Clusters")
bg <- dplyr::select(umap_df, -label_cluster_main_collapsed)
p2 <- ggplot(aes(x = x, y = y), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(
    aes(colour = label_cluster_main_collapsed),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = label_main_collapsed_colours) +
  scale_colour_manual(values = label_main_collapsed_colours) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ label_cluster_main_collapsed, ncol = 2) +
  guides(colour = FALSE) + 
  ggtitle("'Main' cluster-level label")

p1 + p2 + plot_layout(widths = c(1, 2))
```

##### Diagnostic plots

As a sanity check, we can examine the expression of the marker genes for the relevant cell type labels by plotting a heatmap of their expression in:

1. The reference dataset
2. Our dataset

The value of (1) is that we can assess if we believe the genes are indeed good markers of the relevant cell type in the reference dataset.
The value of (2) is that we can check that these genes are useful markers in our dataset (e.g., that they are reasonably well sampled in our data).

```{r}
monocyte_vs_cd4_markers <- metadata(
  pred_cluster_main)$de.genes$`Monocytes`$`T cells, CD4+`
cd4_vs_monocyte_markers <- metadata(
  pred_cluster_main)$de.genes$`T cells, CD4+`$`Monocytes`
markers <- c(
  head(monocyte_vs_cd4_markers, 10),
  head(cd4_vs_monocyte_markers, 10))
```

Here, we specifically select (some of) the most strongly upregulated genes when comparing the `Monocytes` to the `T cells, CD4+` (`dice.Mono_vs_CD4`) and vice-versa (`dice.CD4_vs_Mono`)

Figure \@ref(fig:ref-dice-mono-and-cd4-markers) confirms that both the `dice.Mono_vs_CD4` and `dice.CD4_vs_Mono` marker genes distinguish these two cell types from one another in the `DICE` reference dataset.
However, the `dice.CD4_vs_Mono` marker genes are also expressed in `T cells, CD8+` samples, highlighting that what are useful marker genes in one comparison are not necessarily in another comparison.

```{r ref-dice-mono-and-cd4-markers, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values in the `DICE` reference dataset for selected marker genes between the `Monocytes` and `T cells, CD4+` labels. Each column is a sample, each row a gene", fig.asp = 1.1}
# NOTE: Have to remove column names from DICE to avoid an error.
tmp <- dice
colnames(tmp) <- seq_len(ncol(tmp))

plotHeatmap(
  tmp,
  features = markers,
  colour_columns_by = "label.main",
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = "label.main",
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  annotation_row = data.frame(
    markers = c(rep("dice.Mono_vs_CD4", 10), rep("dice.CD4_vs_Mono", 10)),
    row.names = markers))
```

Figure \@ref(fig:test-dice-mono-and-cd4-markers) shows that both the `dice.Mono_vs_CD4` and `dice.CD4_vs_Mono` marker genes marker genes are indeed very specific to their respective clusters in our dataset.

```{r test-dice-mono-and-cd4-markers, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values in our dataset at the cell-level for selected marker genes between the `Monocytes` and `T cells, CD4+` labels. Each column is a sample, each row a gene. For legibility, only a random 10% of non-`Monocytes` cells are shown.", fig.asp = 1.1}
# NOTE: Alternatively, could plot the cluster-level data.
# tmp <- logNormCounts(
#   sumCountsAcrossCells(
#     sce,
#     ids = colData(sce)[, c("cluster", "label_cluster_main")],
#     subset_row = markers), exprs_values = 1)

set.seed(561)
tmp <- cbind(
  sce[, sce$label_cluster_main == "Monocytes"],
  sce[, sce$label_cluster_main != "Monocytes"][
    , sample(
      sum(sce$label_cluster_main != "Monocytes"),
      0.1 * sum(sce$label_cluster_main != "Monocytes"))])
plotHeatmap(
  tmp,
  features = markers,
  colour_columns_by = c("label_cluster_main", "cluster"),
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = c("label_cluster_main", "cluster"),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  annotation_row = data.frame(
    markers = c(rep("dice.Mono_vs_CD4", 10), rep("dice.CD4_vs_Mono", 10)),
    row.names = markers))
```

#### Checking for enrichment of cells in experimental group

```{r}
keep <- sce$label_cluster_main_collapsed != "Monocytes"
```

We again check whether the cells removed by this procedure are preferentially derive from particular experimental groups.
Figure \@ref(fig:monocytes-highlighting-removed-droplets) shows that excluding these cells will preferentially exclude cells from the `Uninfected` samples.

```{r monocytes-highlighting-removed-droplets, fig.cap = "Droplets removed after excluding droplets from clusters labelled as `Monocytes`, stratified by `Sample`."}
ggplot(
  data.frame(Sample = sce$Sample, keep = keep)) + 
  geom_bar(aes(x = Sample, fill = keep)) + 
  ylab("Number of droplets") + 
  theme_cowplot(font_size = 9) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### Summary

We opt to remove cells from clusters labelled as `Monocytes`.
The removes `r sum(!keep)` droplets, retaining `r sum(keep)` for further analysis.
This will provide better resolution for us to analyse the remaining cells, which are nominally the CD4+ T-cells of interest.

<aside>
If it is biologically relevant that the `Monocytes` are only found in `Uninfected` then we would need to retain these cells for downstream analysis.
</aside>

```{r}
sce <- sce[, keep]
colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")] <-
  droplevels(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")])
sample_colours <- sample_colours[levels(sce$Sample)]
treatment_colours <- treatment_colours[levels(sce$Treatment)]
```

### Re-processing

```{r}
var_fit <- modelGeneVarByPoisson(sce, block = sce$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)

set.seed(11235)
sce <- denoisePCA(
  sce, 
  var_fit, 
  subset.row = hvg,
  BSPARAM = BiocSingular::IrlbaParam(deferred = TRUE))

set.seed(8875)
sce <- runUMAP(sce, dimred = "PCA")
umap_df <- cbind(
  data.frame(
    x = reducedDim(sce, "UMAP")[, 1],
    y = reducedDim(sce, "UMAP")[, 2]),
  as.data.frame(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")]))

set.seed(8111)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
umap_df$cluster <- sce$cluster
cluster_colours <- setNames(
  Polychrome::glasbey.colors(nlevels(sce$cluster) + 1)[-1],
  levels(sce$cluster))
sce$cluster_colours <- cluster_colours[sce$cluster]
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:no-monocytes-clusterplot-umap) and broken down by experimental factors in Figure \@ref(fig:no-monocytes-cluster-barplot).

```{r no-monocytes-clusterplot-umap, fig.cap = "UMAP plot of the updated data, where each point represents a droplet and is coloured according to the legend.", fig.asp = 0.7}
plot_grid(
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = cluster), size = 0.25) +
    scale_colour_manual(values = cluster_colours) + 
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2"),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Treatment), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = treatment_colours),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Sample), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = sample_colours),
  ncol = 2, 
  align = "v")
```

```{r no-monocytes-cluster-barplot, fig.asp = 1 / 4, fig.cap = "Breakdown of clusters by experimental factors."}
plot_grid(
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Sample")])) + 
    geom_bar(
      aes(x = cluster, fill = Sample),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = sample_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Treatment")])) + 
    geom_bar(
      aes(x = cluster, fill = Treatment),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = treatment_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, "cluster", drop = FALSE])) + 
    geom_bar(aes(x = cluster, fill = cluster)) +
    coord_flip() +
    ylab("Number of droplets") +
    scale_fill_manual(values = cluster_colours) +
    theme_cowplot(font_size = 5) + 
    guides(fill = FALSE),
  align = "h",
  ncol = 3)
```

Notably:

- Still, some of the clusters are highly treatment-specific.
- Still, none of the clusters are highly sample-specific.

## 'Known' unwanted cell types

### Motivation

James indicated that there may be a subpopulation of CD8+ T-cells in this dataset.
CD4+ and CD8+ T-cells are notoriously difficult to distinguish from one another using scRNA-seq data^[E.g., see [https://osca.bioconductor.org/cell-type-annotation.html#assigning-cell-labels-from-reference-data](https://osca.bioconductor.org/cell-type-annotation.html#assigning-cell-labels-from-reference-data)].

<aside>
Specifically, James believes that there may be a population of CD8+ T-cells that upregulated the cell-surface expression of CD4 and hence were retained in the enrichment step.
</aside>

### Analysis

Supposing that there are CD8+ T-cells in this dataset, then there are several reasons why the approach taken in ['Unknown' unwanted cell types] did not label any cluster as CD8+ T-cells:

1. If the CD8+ T-cells were spread across several clusters, and in a minority within each of those clusters, then a cluster-level analysis would likely not label any cluster as CD8+ T-cells. 
2. If the marker genes distinguishing CD4+ T-cells and CD8+ T-cells in the reference dataset are poorly chosen
    a. If these genes can't even distinguish CD4+ T-cells and CD8+ T-cells in the reference dataset
    b. If these genes are poorly sampled in our dataset.
    
We explore these issues in turn.
    
#### Cell-level annotations

A cell-level annotation using `r BiocStyle::Biocpkg("SingleR")` may allow us to identify CD8+ T-cells that are clustering with CD4+ T-cells rather than as a distinct cluster.
For simplicity, I have again opted to only use the `DICE` reference annotation but now annotated the dataset at the cell-level using both the 'main' and 'fine' labels.

<aside>
A reminder that the trade-off between cluster-level and cell-level annotation is one of increased robustness to noise (cluster-level) vs. increased resolution (cell-level). The story is similar for the trade-off between using 'main' and 'fine' labels.
</aside>

```{r}
pred_cell_main <- SingleR(
  test = sce,
  ref = ref,
  labels = labels_main,
  BPPARAM = bpparam())
sce$label_cell_main <- factor(pred_cell_main$pruned.labels)
sce$label_cell_main_collapsed <- .collapseLabel(
  sce$label_cell_main,
  sce$batch)
umap_df$label_cell_main_collapsed <- sce$label_cell_main_collapsed

labels_fine <- ref$label.fine
# NOTE: This code doesn't necessarily generalise beyond the DICE main labels.
label_fine_collapsed_colours <- setNames(
  c(
    Polychrome::glasbey.colors(nlevels(factor(labels_fine)) + 1)[-1],
    "orange"),
  c(levels(factor(labels_fine)), "other"))

pred_cell_fine <- SingleR(
  test = sce,
  ref = ref,
  labels = labels_fine,
  BPPARAM = bpparam())
sce$label_cell_fine <- factor(pred_cell_fine$pruned.labels)
sce$label_cell_fine_collapsed <- .collapseLabel(
  sce$label_cell_fine,
  sce$batch)
sce$label_fine_collapsed_colours <- label_fine_collapsed_colours[
  as.character(sce$label_cell_fine_collapsed)]
umap_df$label_cell_fine_collapsed <- sce$label_cell_fine_collapsed
```

The results using the 'main' label is summarised in the table below.
Almost all cells are labelled as `T cells, CD4+`.

```{r}
tabyl(
  data.frame(label.main = sce$label_cell_main, cluster = sce$cluster), 
  label.main,
  cluster) %>%
  adorn_totals("col") %>%
  adorn_percentages("col") %>%
  adorn_pct_formatting() %>%
  adorn_ns() %>%
  knitr::kable(
    caption = "Cell-level assignments using the 'main' labels of the DICE reference.")
```

The results using the 'fine' label is summarised in the table below.
Consistent with the 'main' labels, almost all cells are labelled as a subtype of `T cells, CD4+` cells.

```{r}
tabyl(
  data.frame(label.fine = sce$label_cell_fine, cluster = sce$cluster), 
  label.fine,
  cluster) %>%
  adorn_totals("col") %>%
  adorn_percentages("col") %>%
  adorn_pct_formatting() %>%
  adorn_ns() %>%
  knitr::kable(
    caption = "Cell-level assignments using the 'fine' labels of the DICE reference.")
```

This consistency is further emphasised when we cross-tabulate the 'main' and 'fine' labels.

```{r}
tabyl(
  data.frame(
  label.main = sce$label_cell_main,
  label.fine = sce$label_cell_fine, cluster = sce$cluster),
  label.fine, label.main) %>%
  adorn_totals("row") %>%
  adorn_percentages("col") %>%
  adorn_pct_formatting() %>%
  adorn_ns() %>%
  knitr::kable(
    caption = "Cross-tabulation of the 'main' and 'fine' assignments using the DICE reference.")
```

Figure \@ref(fig:umap-with-fine-cell-labels) overlays the 'fine' cell type labels on the UMAP plot.

```{r umap-with-fine-cell-labels, fig.asp = 1 / 2, fig.cap = "UMAP plot. Each point represents a cluster and is coloured by the 'fine' cell-level label. Each panel highlights droplets from a particular predicted cluster type. Cluster labels with < 1% frequency are grouped together as `other`."}
p1 <- ggplot(aes(x = x, y = y), data = umap_df) +
  geom_point(
    aes(colour = cluster),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = cluster_colours) +
  scale_colour_manual(values = cluster_colours) +
  theme_cowplot(font_size = 10) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  ggtitle("Clusters")
bg <- dplyr::select(umap_df, -label_cell_fine_collapsed)
p2 <- ggplot(aes(x = x, y = y), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.5), size = 0.125) +
  geom_point(
    aes(colour = label_cell_fine_collapsed),
    alpha = 1,
    size = 0.25) +
  scale_fill_manual(values = label_fine_collapsed_colours) +
  scale_colour_manual(values = label_fine_collapsed_colours) +
  theme_cowplot(font_size = 6) +
  xlab("Dimension 1") +
  ylab("Dimension 2") +
  facet_wrap(~ label_cell_fine_collapsed, ncol = 3) +
  guides(colour = FALSE) + 
  ggtitle("'Fine' cell-level label")
p1 + p2 + plot_layout(widths = c(1, 1))
```

Essentially none of the cells are labelled as CD8+ T-cells by this approach.

###### Diagnostic plots

```{r}
library(tibble)
library(tidyr)

dir.create(here("output", "marker_genes", "SingleR"))

cell_main_de_genes <- SingleRDEGsAsTibble(metadata(pred_cell_main)$de.genes)
write.csv(
    cell_main_de_genes,
    gzfile(
      here(
        "output", 
        "marker_genes", 
        "SingleR", 
        "SingleR_markers.DICE.label_cell_main.csv.gz")),
    row.names = FALSE,
    quote = FALSE)

cell_fine_de_genes <- SingleRDEGsAsTibble(metadata(pred_cell_fine)$de.genes)
write.csv(
    cell_fine_de_genes,
    gzfile(
      here(
        "output", 
        "marker_genes", 
        "SingleR", 
        "SingleR_markers.DICE.label_cell_fine.csv.gz")),
    row.names = FALSE,
    quote = FALSE)
```

<aside>
The lists of genes from the `DICE` reference used to annotate these cells with `r BiocStyle::Biocpkg("SingleR")` are available in [`output/marker_genes/SingleR/`](../output/marker_genes/SingleR/). You may wish to look at the expression of these genes yourself to verify/understand the annotations.
</aside>

As a sanity check, we again examine the expression of the marker genes for the relevant cell type labels by plotting a heatmap of their expression in:

1. The reference dataset
2. Our dataset

The value of (1) is that we can assess if we believe the genes are indeed good markers of the relevant cell type in the reference dataset.
The value of (2) is that we can check that these genes are useful markers in our dataset (e.g., that they are reasonably well sampled in our data).

```{r}
markers <- cell_main_de_genes %>%
  dplyr::filter(
    (group1 == "T cells, CD8+" & group2 == "T cells, CD4+") |
      (group1 == "T cells, CD4+" & group2 == "T cells, CD8+")) %>%
  dplyr::filter(rank <= 20) %>%
  dplyr::pull(gene)
```

Here, we specifically select (some of) the most strongly upregulated genes when comparing the `T cells, CD8+` to the `T cells, CD4+` (`dice.CD8_vs_CD4`) and vice-versa (`dice.CD4_vs_CD8`).

Figure \@ref(fig:ref-dice-cd8-and-cd4-markers) confirms that both the `dice.CD8_vs_CD4` and `dice.CD4_vs_CD8` marker genes distinguish these two cell types from one another in the `DICE` reference dataset.

```{r ref-dice-cd8-and-cd4-markers, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values in the `DICE` reference dataset for selected marker genes between the `Monocytes` and `T cells, CD4+` labels. Each column is a sample, each row a gene", fig.asp = 1.1}
# NOTE: Have to remove column names from DICE to avoid an error.
tmp <- dice
colnames(tmp) <- seq_len(ncol(tmp))

plotHeatmap(
  tmp,
  features = markers,
  colour_columns_by = c("label.main", "label.fine"),
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = c("label.main", "label.fine"),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  annotation_row = data.frame(
    markers = c(rep("dice.CD8_vs_CD4", 20), rep("dice.CD4_vs_CD8", 20)),
    row.names = markers))
```

Figure \@ref(fig:test-dice-cd8-and-cd4-markers) shows that very few of the `dice.CD8_vs_CD4` marker genes are expressed at in any cells in our dataset.
In contrast, many of the cells express several of the `dice.CD4_vs_CD8` marker genes.

```{r test-dice-cd8-and-cd4-markers, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values in our dataset at the cell-level for selected marker genes between the `T cells, CD8+` and `T cells, CD4+` labels. Each column is a sample, each row a gene.", fig.asp = 1.1}
plotHeatmap(
  sce,
  features = markers,
  colour_columns_by = c("label_cell_main", "label_cell_fine", "cluster"),
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = c("label_cell_main", "label_cell_fine", "cluster"),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  annotation_row = data.frame(
    markers = c(rep("dice.CD8_vs_CD4", 20), rep("dice.CD4_vs_CD8", 20)),
    row.names = markers))
```

Figure \@ref(fig:subset-test-dice-cd8-and-cd4-markers) shows that even amongst those cells not labelled as `T cells, CD4+`, very few of the `dice.CD8_vs_CD4` marker genes are expressed in our dataset.

```{r subset-test-dice-cd8-and-cd4-markers, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values in our dataset at the cell-level for selected marker genes between the `T cells, CD8+` and `T cells, CD4+` labels. Each column is a sample, each row a gene. Only cells not labelled as `T cells, CD4+` are shown.", fig.asp = 1.1}
plotHeatmap(
  sce[, which(sce$label_cell_main != "T cells, CD4+")],
  features = markers,
  colour_columns_by = c("label_cell_main", "label_cell_fine", "cluster"),
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = c("label_cell_main", "label_cell_fine", "cluster"),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  annotation_row = data.frame(
    markers = c(rep("dice.CD8_vs_CD4", 20), rep("dice.CD4_vs_CD8", 20)),
    row.names = markers))
```
    
##### Summary

By performing a cell-level annotation with `r BiocStyle::Biocpkg("SingleR")`, we have ruled out the possibility that the absence of CD8+ T-cells identified in ['Unknown' unwanted cell types] is due to this analysis being performed at the cluster-level.
In fact, the cell-level analysis has provided stronger evidence that these cells are almost all various subtypes of CD4+ T-cells.

However, we also observed that the `dice.CD8_vs_CD4` marker genes are poorly sampled in our dataset, leaving open the possibility that a different choice of marker genes would allow us to distinguish the two cell types and identify any stray CD8+ T-cells.
We pursue this approach in the next section.

#### Alternative marker gene lists

```{r}
james_cd8_markers <- c("GNLY", "GZMA", "GZMK")
```

As an alternative to using the `DICE`-derived marker genes, we could use any other list of putative marker genes.
James provided some genes that he believes are markers of the unwanted CD8+ cells, namely `r glue::glue_collapse(james_cd8_markers, sep = ", ", last = ", and ")`.
We look at the expression of these in both the `DICE` reference dataset and in our dataset.

##### Diagnostic plots

Figure \@ref(fig:ref-james-cd8-markers) shows that these genes are arguably stronger markers of NK cells than they are of CD8+ cells.
More importantly, these genes are highly expressed in several CD4+ T-cell subtypes in the `DICE` reference dataset.

```{r ref-james-cd8-markers, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values in the `DICE` reference dataset for 'CD8+ T-cell' marker genes provided by James. Each column is a sample, each row a gene", fig.asp = 1.1}
# NOTE: Have to remove column names from DICE to avoid an error.
tmp <- dice
colnames(tmp) <- seq_len(ncol(tmp))

plotHeatmap(
  tmp,
  features = james_cd8_markers,
  colour_columns_by = c("label.main", "label.fine"),
  center = TRUE,
  symmetric = TRUE,
  cluster_rows = TRUE,
  cluster_cols = TRUE)
```

Consistent with this, Figure \@ref(fig:test-james-cd8-markers) shows high expression of these genes in cells labelled as various subtypes of CD4+ T-cells.

```{r test-james-cd8-markers, fig.wide = TRUE, fig.cap = "Heatmap of log-expression values in our dataset at the cell-level for 'CD8+ T-cell' marker genes provided by James. Each column is a sample, each row a gene.", fig.asp = 1.1}
plotHeatmap(
  sce,
  features = james_cd8_markers,
  colour_columns_by = c("label_cell_main", "label_cell_fine", "cluster"),
  center = TRUE,
  symmetric = TRUE,
  order_columns_by = c("label_cell_main", "label_cell_fine", "cluster"),
  cluster_rows = TRUE,
  cluster_cols = TRUE)
```

Furthermore, Figure \@ref(fig:test-james-cd8-markers) shows high expression of these genes for those cells labelled as `NK cells` and low expression of those same genes in the few cells labelled as `T cells, CD8`.

##### Summary

There is no evidence in the `DICE` reference dataset that `r glue::glue_collapse(james_cd8_markers, sep = ", ", last = ", and ")` are markers of CD8+ T-cells.
To the contrary, the `DICE` dataset provides strong evidence that these are markers of various CD4+ T-cell subtypes and NK cells.

<aside>
We could extend this analysis using a different set of 'CD8+ T-cell' marker genes, but I don't think this is necessary or fruitful analysis direction.
</aside>

#### Summary

- We identified a small number of `Monocytes` that we excluded from further analysis.
- We did not identify any of the suspected CD8+ T-cells.
- Instead, we found strong evidence that almost all the remaining cells are various subtypes of CD4+ T-cells.

# Summary

After extensive analysis we have now identified those droplets containing 'biologically relevant' cells (n = `r ncol(sce)`).
Specifically, we have selected for singlets that are CD4+ T-cells.
We can verify that we have selected CD4+ T-cells by looking at the expression of known marker genes.

### Exclusion of ribosomal protein and mitochondrial genes from HVGs

Figure \@ref(fig:cd4-markers-umap) gives an example using some marker genes of `T cells, CD4+` cells from the `DICE` reference dataset.

```{r cd4-markers-umap, fig.cap = "UMAP plot of the updated data, where each point represents a cell and is coloured according to expression of selected genes. The selected genes are markers of the `T cells, CD4+` cells in the `DICE` reference dataset that are also highly expressed in our dataset.", fig.asp = 0.8}
# NOTE: This code was written before I had SingleRDEGsAsTibble().
all_markers <- metadata(pred_cell_main)$de.genes
cd4_markers <- all_markers[["T cells, CD4+"]]
cd4_markers_t <- table(unlist(cd4_markers))

# Three approaches to selecting markers:
# 
# 1. Identify genes occurring in most pairwise comparisons
#      `markers <- names(sort(cd4_markers_t, decreasing = TRUE))`
# 2. Identify the markers genes that are most highly expressed (on average)
#    in our dataset.
#     `markers <- names(sort(rowMeans(logcounts(sce)[names(cd4_markers_t), ]), decreasing = TRUE))`
# 3. A compromise between (1) and (2), here selecting most highly expressed markers that occur in at least X pairwise comparisons
#     `markers <- names(sort(rowMeans(logcounts(sce)[names(cd4_markers_t[cd4_markers_t >= X]), ]), decreasing = TRUE))`

# NOTE: Opted to go with (3) with X = 2
markers <- names(
  sort(
    rowMeans(logcounts(sce)[names(cd4_markers_t[cd4_markers_t >= 2]), ]),
    decreasing = TRUE))

# NOTE: Have to remove `TRA` and `TRB` before create the dataframe.
tmp <- sce
colData(tmp) <- colData(tmp)[!colnames(colData(tmp)) %in% c("TRA", "TRB")]
p <- lapply(head(markers, 9), function(marker) {
  b <- makePerCellDF(tmp, features = marker) %>%
    tidyr::pivot_longer(
      all_of(marker),
      names_to = "feature",
      values_to = "logcounts")
  ggplot(data = b, aes(x = UMAP.1, y = UMAP.2)) + 
    geom_point(aes(colour = logcounts), size = 1/9) + 
    scale_colour_viridis_c(option = "magma") + 
    theme_cowplot(font_size = 8) + 
    ggtitle(marker)
})
plot_grid(plotlist = p, ncol = 3)
```

## Re-processing

We perform a final re-processing of the 'biologically relevant' cells.
Notably, we opt at this stage to exclude ribosomal protein and mitochondrial genes from the list of highly variable genes, for reasons example below.

```{r}
var_fit <- modelGeneVarByPoisson(sce, block = sce$batch)
hvg <- getTopHVGs(var_fit, var.threshold = 0)
```

We find that the most highly variable genes in this dataset are somewhat enriched for ribosomal protein genes^[Here, ribosomal protein genes are defined as those gene symbols starting with "RPL" or "RPS" or otherwise found in the ["KEGG_RIBOSOME" gene set published by MSigDB](https://www.gsea-msigdb.org/gsea/msigdb/cards/KEGG_RIBOSOME.html), namely: `r glue::glue_collapse(sort(ribo_set), sep = ", ")`] (n = `r sum(is_ribo)`) and mitochondrial genes (n = `r sum(is_mito)`), with Figure \@ref(fig:perc-mito-and-ribo) showing that more than 20% of the top-200 HVGs are ribosomal protein or mitochondrial genes.

```{r perc-mito-and-ribo, fig.cap = "Percentage of top-K HVGs that are mitochondrial or ribosomal protein genes."}
is_mito <- hvg %in% mito_set
is_ribo <- hvg %in% ribo_set

plot(
  100 * cumsum(is_mito) / seq_along(hvg),
  log = "x",
  ylim = c(0, 100),
  ylab = "%",
  xlab = "Top-k genes",
  col = "dodgerBlue",
  pch = 16)
points(100 * cumsum(is_ribo) / seq_along(hvg), col = "orange", pch = 16)
points(100 * cumsum(is_mito | is_ribo) / seq_along(hvg), col = "black", pch = 16)
legend(
  "topright",
  pch = 16,
  col = c("black", "orange", "dodgerBlue"),
  legend = c("Both", "Ribosomal protein", "Mitochondrial"))
```

Ribosomal protein and mitochondrial genes are of lesser biological relevance to this study, so we it was decided to exclude them from the HVGs.
This means that these genes can no longer **directly** influence some of the subsequent steps in the analysis, including:

- Dimensionality reduction
  - Principal component analysis (PCA)
  - Uniform manifold approximation and projection (UMAP)
- Data integration
  - Mutual nearest neighbours (MNN)
- Clustering

Although the exclusion of these genes from the HVGs prevents them from directly influencing these analyses, they may still **indirectly** influence these steps or otherwise be associated with their outcomes.
For example, if there is a set of (non ribosomal protein) genes that are strongly associated with ribosomal protein gene expression, then we may still see a cluster associated with ribosomal protein gene expression.

Finally, and to emphasise, we have only excluded ribosomal protein and mitochondrial genes from the HVGs, i.e. we have not excluded them entirely from the dataset.
In particular, this means that these genes may appear in downstream results (e.g., tables of cluster marker genes and differentially expressed genes).

```{r}
hvg <- hvg[!(is_mito | is_ribo)]
```

### Visualisation

```{r}
set.seed(11235)
sce <- denoisePCA(
  sce, 
  var_fit, 
  subset.row = hvg,
  BSPARAM = BiocSingular::IrlbaParam(deferred = TRUE))

set.seed(8875)
sce <- runUMAP(sce, dimred = "PCA")
umap_df <- cbind(
  data.frame(
    x = reducedDim(sce, "UMAP")[, 1],
    y = reducedDim(sce, "UMAP")[, 2]),
  as.data.frame(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")]))

set.seed(8111)
snn_gr <- buildSNNGraph(sce, use.dimred = "PCA")
clusters <- igraph::cluster_louvain(snn_gr)
sce$cluster <- factor(clusters$membership)
umap_df$cluster <- sce$cluster
cluster_colours <- setNames(
  Polychrome::glasbey.colors(nlevels(sce$cluster) + 1)[-1],
  levels(sce$cluster))
sce$cluster_colours <- cluster_colours[sce$cluster]
```

There are `r nlevels(sce$cluster)` clusters detected, shown on the UMAP plot Figure \@ref(fig:selected-cells-clusterplot-umap) and broken down by experimental factors in Figure \@ref(fig:selected-cells-cluster-barplot).

```{r selected-cells-clusterplot-umap, fig.cap = "UMAP plot of the updated data, where each point represents a droplet and is coloured according to the legend.", fig.asp = 0.7}
plot_grid(
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = cluster), size = 0.25) +
    scale_colour_manual(values = cluster_colours) + 
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2"),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Treatment), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = treatment_colours),
  ggplot(aes(x = x, y = y), data = umap_df) +
    geom_point(aes(colour = Sample), size = 0.25) +
    theme_cowplot(font_size = 8) + 
    xlab("Dimension 1") + 
    ylab("Dimension 2") +
    scale_colour_manual(values = sample_colours),
  ncol = 2, 
  align = "v")
```

```{r selected-cells-cluster-barplot, fig.asp = 1 / 4, fig.cap = "Breakdown of clusters by experimental factors."}
plot_grid(
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Sample")])) + 
    geom_bar(
      aes(x = cluster, fill = Sample),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = sample_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, c("cluster", "Treatment")])) + 
    geom_bar(
      aes(x = cluster, fill = Treatment),
      position = position_fill(reverse = TRUE)) +
    coord_flip() +
    ylab("Frequency") +
    scale_fill_manual(values = treatment_colours) +
    theme_cowplot(font_size = 5),
  ggplot(as.data.frame(colData(sce)[, "cluster", drop = FALSE])) + 
    geom_bar(aes(x = cluster, fill = cluster)) +
    coord_flip() +
    ylab("Number of droplets") +
    scale_fill_manual(values = cluster_colours) +
    theme_cowplot(font_size = 5) + 
    guides(fill = FALSE),
  align = "h",
  ncol = 3)
```

Notably:

- Still, some of the clusters are highly treatment-specific.
- Still, none of the clusters are highly sample-specific.

# Concluding remarks

```{r}
saveRDS(
  sce,
  here("data", "SCEs", "C057_Cooney.cells_selected.SCE.rds"),
  compress = "xz")
```
The processed *SingleCellExperiment* object is available (see [`data/SCEs/C057_Cooney.cells_selected.SCE.rds`](../data/SCEs/C057_Cooney.cells_selected.SCE.rds)).
This will be used in downstream analyses, e.g., identifying cluster marker genes and refining the cell labels.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

</details>
