---
title: "Demultiplexing the Cooney (C057) memory CD4+ T-cell data set"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: WEHI SCORE
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: distill::distill_article
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(here)
library(magrittr)
library(BiocStyle)
library(dplyr)
library(janitor)
library(cowplot)

source(here("code", "helper_functions.R"))

# NOTE: Using >= 4 cores seizes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 2L, 3L))

knitr::opts_chunk$set(fig.path = "C057_Cooney.demultiplex_files/")
```

# Introduction

Cells were obtained from six samples.
These samples were processed a technique called using Cell Hashing, a method that enables sample multiplexing. 
Cell Hashing uses a series of oligo-tagged antibodies against ubiquitously expressed surface proteins with different barcodes to uniquely label cells from distinct samples, which can be subsequently pooled in one scRNA-seq run.
By sequencing these tags alongside the cellular transcriptome, we can assign each cell to its sample of origin, and robustly identify doublets originating from multiple samples.

In a typical Cell Hashing experiment, each sample is uniquely labelled with a single hashtag oligonucleotide (HTO).
However, in this experiment we needed to label 6 samples but only had 5 HTOs.
We decided to uniquely label five of the samples (three infected, two uninfected) with a single HTO and to label the sixth sample with all five HTOs.
This non-standard use of HTOs meant we could not rely on standard cell hashing demultiplexing routines, like that available in `r BiocStyle::CRANpkg("Seurat")`.

# Setting up the data

The count data were processed using **CellRanger** and the `r Biocpkg("DropletUtils")` R/Bioconductor packages.
The counts and their metadata are available in a *SingleCellExperiment* object available as [`data/SCEs/HTLV_GEX_HTO.CellRanger.SCE.rds`](../data/SCEs/HTLV_GEX_HTO.CellRanger.SCE.rds).
These are the *unfiltered* data, i.e. the data includes all potential genes and barcodes.

```{r}
sce <- readRDS(here("data", "SCEs", "C057_Cooney.CellRanger.SCE.rds"))
```

# Calling cells from empty droplets

An interesting aspect of droplet-based data is that we have no prior knowledge about which droplets (i.e. cell barcodes) actually contain cells, and which are empty. 
Thus, we need to call cells from empty droplets based on the observed expression profiles.
This is done separately for each 10x run.

Calling empty droplets is not entirely straightforward as empty droplets can contain ambient (i.e. extracellular) RNA that can be captured and sequenced. 
The distribution of total counts exhibits a sharp transition between barcodes with large and small total counts (Figure \@ref(fig:rankplot)), probably corresponding to cell-containing and empty droplets respectively.

```{r rankplot, fig.cap = "Total UMI count for each barcode in the dataset, plotted against its rank (in decreasing order of total counts). The inferred locations of the inflection (dark green dashed lines) and knee points (blue dashed lines) are also shown.", fig.asp = 1}
library(DropletUtils)
bcrank <- barcodeRanks(counts(sce))
# Only showing unique points for plotting speed.
uniq <- !duplicated(bcrank$rank)
plot(
  x = bcrank$rank[uniq], 
  y = bcrank$total[uniq], 
  log = "xy",
  xlab = "Rank", 
  ylab = "Total UMI count", 
  main = "C057_Cooney",
  cex.lab = 1.2,
  xlim = c(1, 500000),
  ylim = c(1, 50000))
abline(h = metadata(bcrank)$inflection, col = "darkgreen", lty = 2)
abline(h = metadata(bcrank)$knee, col = "dodgerblue", lty = 2)
legend(
  "bottomleft",
  legend = c("Inflection", "Knee"), 
  col = c("darkgreen", "dodgerblue"),
  lty = 2,
  cex = 1.2)
```

We use the `emptyDrops()` function from the `r Biocpkg("DropletUtils")` package to test whether the expression profile for each cell barcode is significantly different from the ambient RNA pool [@lun2018distinguishing].
This tends to be less conservative than the cell calling algorithm from the **CellRanger** pipeline, which often discards genuine cells with low RNA content (and thus low total counts).
Any significant deviation indicates that the barcode corresponds to a cell-containing droplet.
We call cells at a false discovery rate (FDR) of 1%, meaning that no more than 1% of our called barcodes should be empty droplets on average.

```{r}
empties <- readRDS(
  here("data", "emptyDrops", "C057_Cooney.emptyDrops.rds"))
dplyr::mutate(as.data.frame(empties), Sample = rep("C057", nrow(empties))) %>%
  dplyr::group_by(Sample) %>%
  dplyr::summarise(
    keep = sum(FDR < 0.001, na.rm = TRUE), 
    n = dplyr::n(),
    remove = n - keep) %>%
  dplyr::mutate(library = factor(Sample)) %>%
  dplyr::select(library, keep, remove) %>%
  knitr::kable(
    caption = "Number of droplets kept and removed after filtering empty drops.")
sce_empties <- sce[, -which(empties$FDR <= 0.001)]
sce <- sce[, which(empties$FDR <= 0.001)]
```

# Demultiplexing with hashtag oligos (HTOs)

We only use the droplets identified as non-empty in [Calling cells from empty droplets].

```{r}
# Select cell barcodes detected by both RNA and HTOs
rna_bcs <- colSums(counts(sce)) > 0
hto_bcs <- colSums(counts(altExp(sce, "Antibody Capture"))) > 0
joint_bcs <- rna_bcs & hto_bcs
sce <- sce[, joint_bcs]
```

These samples were processed using 5 HTOs (`human_1`, `human_2`, `human_3`, `human_4`, and `human_5`).
Nonetheless, we ran **CellRanger** using a larger panel of HTOs (n = `r nrow(altExp(sce, "Antibody Capture"))`) to enable us to check for background contamination of HTOs.

Figure \@ref(fig:htos) plots the distribution of each HTO counts for the the 8 most frequently HTOs detected and shows that HTOs `human_1`, `human_2`, `human_3`, `human_4`, and `human_5` are clearly detected more frequently than the other barcodes, as we would hope.

```{r htos, fig.cap = "Distribution of HTO counts in the dataset. Only those HTOs with more detected in at least one cell are shown. The red vertical line denotes detecting the HTO 10 times in a sample.", layout = "l-page", fig.asp = 2 / 4}
par(mfrow = c(2, 4))
o <- order(rowSums(counts(altExp(sce, "Antibody Capture"))), decreasing = TRUE)
for (i in o[1:8]) {
  if (rowSums(counts(altExp(sce, "Antibody Capture")))[i] > 10) {
    plot(
      table(counts(altExp(sce, "Antibody Capture"))[i, ]),
      main = rownames(altExp(sce, "Antibody Capture"))[i],
      xlim = c(1, 10 ^ 5),
      log = "x",
      xlab = "Detections",
      ylab = "Frequency")
    abline(v = 10, col = "red")
  }
}
```

We therefore focus on assigning cells to just the `human_1`, `human_2`, `human_3`, `human_4`, and `human_5` HTOs, along with the combination of all five HTOs.

```{r}
altExp(sce, "Antibody Capture") <- altExp(
  sce, "Antibody Capture")[paste0("human_", 1:5), ]
```

We compute median-based size factors of the HTO counts and use these to normalize the HTO counts^[Median-based size factors can adjust for the composition bias that is inherent to the HTO counts; see [https://osca.bioconductor.org/integrating-with-protein-abundance.html#normalization-1](https://osca.bioconductor.org/integrating-with-protein-abundance.html#normalization-1) for details.].
This requires an estimate of the ambient expression of each HTO, which we estimate from the empty droplets.

<aside>
It's noteworthy that the ambient expression varies across the HTOs, with a 4-fold difference between the least and most abundant HTO.
</aside>

```{r}
ambient <- rowMeans(counts(altExp(sce_empties)))[rownames(altExp(sce))]
as.data.frame(ambient) %>%
  knitr::kable(digits = 1, caption = "Estimated ambient counts for each HTO.")
```

```{r}
library(scater)
sf_amb <- medianSizeFactors(
  altExp(sce, "Antibody Capture"),
  reference = ambient)
# NOTE: Size factors should be positive.
sf_amb[sf_amb == 0] <- min(sf_amb[sf_amb > 0])
```

We then cluster the log-expression of the HTOs to identify samples with similar HTO expression profiles.

```{r}
library(scran)
sizeFactors(altExp(sce, "Antibody Capture")) <- sf_amb
altExp(sce, "Antibody Capture") <- logNormCounts(
  altExp(sce, "Antibody Capture"))
# NOTE: `d = NA` means no dimensionality reduction is performed.
# NOTE: `k = 100` was selected by trial and error to get a reasonable number of 
#       clusters that avoided overclustering the multi-HTO samples.
g <- buildSNNGraph(altExp(sce, "Antibody Capture"), k = 100, d = NA)
clusters <- igraph::cluster_louvain(g)$membership
sce$hto_cluster <- factor(clusters)
hto_cluster_colours <- setNames(
  palette("Okabe-Ito")[seq_len(nlevels(sce$hto_cluster))],
  levels(sce$hto_cluster))
sce$hto_cluster_colours <- hto_cluster_colours[sce$hto_cluster]
stopifnot(nlevels(sce$hto_cluster) == 7)
```

## Visualize demultiplexing results

Figures \@ref(fig:pca) and \@ref(fig:pca-faceted) use principal component analysis (PCA) to show that five clusters are fairly distinguishable from each other and that there are two additional clusters that are more difficult to resolve.

```{r pca, fig.cap = "PCA plot of the HTO data. Each point represents a cell with the colour explained in the legend.", fig.asp = 0.8}
set.seed(666)
sce <- runPCA(sce, altexp = "Antibody Capture", name = "HTO_PCA")

plotReducedDim(sce, "HTO_PCA", colour_by = "hto_cluster", point_size = 0) +
  geom_point(aes(colour = colour_by), size = 0.5) +
  scale_colour_manual(values = hto_cluster_colours, name = "hto_cluster") +
  ggtitle("PCA: HTOs") +
  theme_cowplot()
```

```{r pca-faceted, fig.cap = "PCA plot of the HTO data. Each panel highlights cells from a particular cluster.", fig.asp = 1}
pca <- cbind(
  as.data.frame(colData(sce)),
  x = reducedDim(sce, "HTO_PCA")[, 1],
  y = reducedDim(sce, "HTO_PCA")[, 2])
bg <- dplyr::select(pca, -hto_cluster)
ggplot(aes(x = x, y = y), data = pca) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.7), size = 0.1) +
  geom_point(aes(colour = hto_cluster), alpha = 1, size = 0.5) +
  scale_fill_manual(values = hto_cluster_colours, name = "Cluster") + 
  scale_colour_manual(values = hto_cluster_colours, name = "Cluster") +
  theme_cowplot(font_size = 10) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2") +
  facet_wrap(~hto_cluster, ncol = 3, labeller = label_both) +
  theme_cowplot() +
  theme(legend.position = "none")
```

As an alternative to PCA, we can uniform manifold approximation and projection (UMAP) method [@McInnes2018-hy] to visualise the HTO data in 2-dimensions, overlaying the assigned cluster labels.

```{r}
set.seed(666)
library(uwot)
sce <- runUMAP(sce, dimred = "HTO_PCA", name = "HTO_UMAP")
```

Figures \@ref(fig:umap) and \@ref(fig:umap-faceted) show that five clusters are clearly distinguishable from each other and that the two additional clusters are a little harder to visually resolve.

```{r umap, fig.cap = "UMAP plot of the HTO data. Each point represents a cell with the colour explained in the legend.", fig.asp = 0.8}
plotReducedDim(sce, "HTO_UMAP", colour_by = "hto_cluster", point_size = 0) +
  geom_point(aes(colour = colour_by), size = 0.5) +
  scale_colour_manual(values = hto_cluster_colours, name = "hto_cluster") +
  ggtitle("UMAP: HTOs") +
  theme_cowplot()
```

```{r umap-faceted, fig.cap = "UMAP plot of the HTO data. Each panel highlights cells from a particular cluster.", fig.asp = 1}
umap_df <- cbind(
  as.data.frame(colData(sce)[, !colnames(colData(sce)) %in% c("TRA", "TRB")]),
  x = reducedDim(sce, "HTO_UMAP")[, 1],
  y = reducedDim(sce, "HTO_UMAP")[, 2])
bg <- dplyr::select(umap_df, -hto_cluster)
ggplot(aes(x = x, y = y), data = umap_df) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.7), size = 0.1) +
  geom_point(aes(colour = hto_cluster), alpha = 1, size = 0.5) +
  scale_fill_manual(values = hto_cluster_colours, name = "Cluster") + 
  scale_colour_manual(values = hto_cluster_colours, name = "Cluster") +
  theme_cowplot(font_size = 10) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2") +
  facet_wrap(~hto_cluster, ncol = 3, labeller = label_both) +
  theme_cowplot() +
  theme(legend.position = "none")
```

Figure \@ref(fig:hto-heatmap) is a heatmap of the HTO counts by cluster and shows:

- Five clusters each containing droplets with large counts for a single HTO correspond to the droplets labelled with a single HTO.
- One cluster containing droplets with moderate-to-large counts for all 5 HTOs corresponds to the droplets labelled with all 5 HTOs.
- One cluster containing a majority of droplets with low counts for all 5 HTOs and a minority of droplets with moderate-to-high counts of some (but not all) 5 HTOs. The majority correspond to droplets that we cannot assign to an individual sample whereas the minority may represent doublets.

```{r hto-heatmap, fig.cap = "Heatmap of log2(counts) for the HTOs."}
# NOTE: This plot is the same as the following, but allows me to specify the 
#       `annotation_colours`.
# assay(altExp(sce), "log2(counts+1)") <- log2(counts(altExp(sce)) + 1)
# plotHeatmap(
#   altExp(sce),
#   color = viridisLite::inferno(100),
#   rownames(altExp(sce)),
#   colour_columns_by = "hto_cluster",
#   exprs_values = "log2(counts+1)",
#   order_columns_by = "hto_cluster",
#   cluster_rows = FALSE)

library(pheatmap)
pheatmap(
  log2(counts(altExp(sce)) + 1)[, order(sce$hto_cluster)],
  color = viridisLite::inferno(100),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  annotation_col = data.frame(
    hto_cluster = sce$hto_cluster,
    row.names = colnames(sce)),
  annotation_colours = list(hto_cluster = hto_cluster_colours),
  show_colnames = FALSE,
  scale = "none")
```

## Assignment of HTO clusters to samples

James provided me with a table linking HTOs to samples, shown below.

```{r}
hto_to_sample_df <- data.frame(
  HTO = paste0("human_", c(1:5, paste0(1:5, collapse = "_"))),
  Sample = c(paste0("infected_", 1:3), paste0("uninfected_", 1:3)),
  Treatment = c(rep("Infected", 3), rep("Uninfected", 3)),
  Replicate = rep(1:3, 2))

knitr::kable(hto_to_sample_df, caption = "Table linking HTOs to samples")
```

James was targeting ~2000 cells / sample.
The table below shows that we largely hit that target for the uninfected samples but not so for the infected samples.
It also shows that the proportion of droplets that are 'unassigned' (i.e. those in cluster (`r which.max(table(sce$hto_cluster))`) is larger than we would like.
These unassigned droplets likely include true doublets, mis-assigned singlets from the cells labelled with all five HTOs, and samples comprising ambient RNAs and HTOs (aka the 'soup' [@young10soupx]).

```{r}
# Map clusters to HTOs to samples
# NOTE: This is made by visually inspecting the above heatmaps.
cluster_to_hto_df <- data.frame(
  hto_cluster = factor(levels(sce$hto_cluster)),
    HTO = c(
    NA_character_,
    "human_1",
    "human_2",
    paste0("human_", c(paste0(1:5, collapse = "_"))), 
    "human_3",
    "human_4",
    "human_5"))

hto_df <- left_join(cluster_to_hto_df, hto_to_sample_df)
# NOTE: This is a bit clunky because the colData contains SplitDataFrameList
#       columns that would otherwise not survive the conversion to a data.frame.
tmp <- as.data.frame(
  colData(sce)[, c("hto_cluster"), drop = FALSE]) %>%
  left_join(hto_df)
colData(sce) <- cbind(
  colData(sce)[, c("Barcode", "project", "hto_cluster_colours", "TRA", "TRB")],
  tmp)

knitr::kable(
  hto_df %>%
    left_join(
    tabyl(data.frame(hto_cluster = sce$hto_cluster), hto_cluster) %>%
      adorn_pct_formatting(1)) %>%
    dplyr::arrange(Sample), 
  caption = "Tabulation of samples by treatment and replicate (mouse). The samples are unpaired. 'NA' values are those samples who HTOs could not be confidently assigned to a single `Sample`.")
```

We will keep these 'unknown' droplets as their own category to see if these cells are transcriptomically distinct, which may indicate an issue with cell hashing for certain types of cells.

# Concluding remarks

```{r}
saveRDS(
  sce,
  here("data", "SCEs", "C057_Cooney.demultiplexed.SCE.rds"),
  compress = "xz")
```

The processed *SingleCellExperiment* object is available (see [`data/SCEs/C057_Cooney.demultiplexed.SCE.rds`](../data/SCEs/C057_Cooney.demultiplexed.SCE.rds)).
This will be used in downstream analyses, e.g., pre-processing.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

</details>
