---
title: "Demultiplexing the Cooney (C057) memory CD4+ T-cell data set"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: WEHI SCORE
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: distill::distill_article
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(here)
library(magrittr)
library(BiocStyle)
library(dplyr)
library(janitor)
library(cowplot)

source(here("code", "helper_functions.R"))

# NOTE: Using >= 4 cores siezes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 2L, 3L))

knitr::opts_chunk$set(fig.path = "C057_Cooney.demultiplex_files/")
```

# Introduction

Cells were obtained from six samples.
These samples were processed a technique called using Cell Hashing, a method that enables sample multiplexing. 
Cell Hashing uses a series of oligo-tagged antibodies against ubiquitously expressed surface proteins with different barcodes to uniquely label cells from distinct samples, which can be subsequently pooled in one scRNA-seq run.
By sequencing these tags alongside the cellular transcriptome, we can assign each cell to its sample of origin, and robustly identify doublets originating from multiple samples.

In a typical Cell Hashing experiment, each sample is uniquely labelled with a single hashtag oligonucleotide (HTO).
However, in this experiment we needed to label 6 samples but only had 5 HTOs.
We decided to uniquely label five of the samples (three infected, two uninfected) with a single HTO and to label the sixth sample with all five HTOs.
This non-standard use of HTOs meant we could not rely on standard cell hashing demultiplexing routines, like that available in `r BiocStyle::CRANpkg("Seurat")`.

# Setting up the data

The count data were processed using **CellRanger** and the `r Biocpkg("DropletUtils")` R/Bioconductor packages.
The counts and their metadata are available in a *SingleCellExperiment* object available as [`data/SCEs/HTLV_GEX_HTO.CellRanger.SCE.rds`](../data/SCEs/HTLV_GEX_HTO.CellRanger.SCE.rds).
These are the *unfiltered* data, i.e. the data includes all potential genes and barcodes.

```{r}
sce <- readRDS(here("data", "SCEs", "C057_Cooney.CellRanger.SCE.rds"))
```

# Calling cells from empty droplets

An interesting aspect of droplet-based data is that we have no prior knowledge about which droplets (i.e. cell barcodes) actually contain cells, and which are empty. 
Thus, we need to call cells from empty droplets based on the observed expression profiles.
This is done separately for each 10x run.

Calling empty droplets is not entirely straightforward as empty droplets can contain ambient (i.e. extracellular) RNA that can be captured and sequenced. 
The distribution of total counts exhibits a sharp transition between barcodes with large and small total counts (Figure \@ref(fig:rankplot)), probably corresponding to cell-containing and empty droplets respectively.

```{r rankplot, fig.cap = "Total UMI count for each barcode in the dataset, plotted against its rank (in decreasing order of total counts). The inferred locations of the inflection (dark green dashed lines) and knee points (blue dashed lines) are also shown.", fig.asp = 1}
library(DropletUtils)
bcrank <- barcodeRanks(counts(sce))
# Only showing unique points for plotting speed.
uniq <- !duplicated(bcrank$rank)
plot(
  x = bcrank$rank[uniq], 
  y = bcrank$total[uniq], 
  log = "xy",
  xlab = "Rank", 
  ylab = "Total UMI count", 
  main = "C057_Cooney",
  cex.lab = 1.2,
  xlim = c(1, 500000),
  ylim = c(1, 50000))
abline(h = metadata(bcrank)$inflection, col = "darkgreen", lty = 2)
abline(h = metadata(bcrank)$knee, col = "dodgerblue", lty = 2)
legend(
  "bottomleft",
  legend = c("Inflection", "Knee"), 
  col = c("darkgreen", "dodgerblue"),
  lty = 2,
  cex = 1.2)
```

We use the `emptyDrops()` function from the `r Biocpkg("DropletUtils")` package to test whether the expression profile for each cell barcode is significantly different from the ambient RNA pool [@lun2018distinguishing].
This tends to be less conservative than the cell calling algorithm from the **CellRanger** pipeline, which often discards genuine cells with low RNA content (and thus low total counts).
Any significant deviation indicates that the barcode corresponds to a cell-containing droplet.
We call cells at a false discovery rate (FDR) of 1%, meaning that no more than 1% of our called barcodes should be empty droplets on average.

```{r}
empties <- readRDS(
  here("data", "emptyDrops", "C057_Cooney.emptyDrops.rds"))
dplyr::mutate(as.data.frame(empties), Sample = rep("C057", nrow(empties))) %>%
  dplyr::group_by(Sample) %>%
  dplyr::summarise(
    keep = sum(FDR < 0.001, na.rm = TRUE), 
    n = dplyr::n(),
    remove = n - keep) %>%
  dplyr::mutate(library = factor(Sample)) %>%
  dplyr::select(library, keep, remove) %>%
  knitr::kable(
    caption = "Number of droplets kept and removed after filtering empty drops.")
sce <- sce[, which(empties$FDR <= 0.001)]
```

# Demultiplexing with hashtag oligos (HTOs)

We only use the droplets identified as non-empty in [Calling cells from empty droplets].

```{r}
# Select cell barcodes detected by both RNA and HTOs
rna_bcs <- colSums(counts(sce)) > 0
hto_bcs <- colSums(counts(altExp(sce, "Antibody Capture"))) > 0
joint_bcs <- rna_bcs & hto_bcs
sce <- sce[, joint_bcs]
```

These samples were processed using 5 HTOs (`human_1`, `human_2`, `human_3`, `human_4`, and `human_5`).
Nonetheless, we ran **CellRanger** using a larger panel of HTOs (n = `r nrow(altExp(sce, "Antibody Capture"))`) to enable us to check for background contamination of HTOs.

Figure \@ref(fig:htos) plots the distribution of each HTO counts for the the 8 most frequently HTOs detected and shows that HTOs `human_1`, `human_2`, `human_3`, `human_4`, and `human_5` are clearly detected more frequently than the other barcodes, as we would hope.

```{r htos, fig.cap = "Distribution of HTO counts in the dataset. Only those HTOs with more detected in at least one cell are shown. The red vertical line denotes detecting the HTO 10 times in a sample.", layout = "l-page", fig.asp = 2 / 4}
par(mfrow = c(2, 4))
o <- order(rowSums(counts(altExp(sce, "Antibody Capture"))), decreasing = TRUE)
for (i in o[1:8]) {
  if (rowSums(counts(altExp(sce, "Antibody Capture")))[i] > 10) {
    plot(
      table(counts(altExp(sce, "Antibody Capture"))[i, ]),
      main = rownames(altExp(sce, "Antibody Capture"))[i],
      xlim = c(1, 10 ^ 5),
      log = "x",
      xlab = "Detections",
      ylab = "Frequency")
    abline(v = 10, col = "red")
  }
}
```

We therefore focus on assigning cells to just the `human_1`, `human_2`, `human_3`, `human_4`, and `human_5` HTOs, along with the combination of all five HTOs.

```{r}
altExp(sce, "Antibody Capture") <- altExp(
  sce, "Antibody Capture")[paste0("human_", 1:5), ]
```

We perform library-size normalization of the HTO counts and then cluster the log-expression of the HTOs to identify samples with similar HTO expression profiles.

```{r}
library(scater)
# Compute size factors
sf_lib <- librarySizeFactors(altExp(sce, "Antibody Capture"))

library(scran)
sizeFactors(altExp(sce, "Antibody Capture")) <- sf_lib
altExp(sce, "Antibody Capture") <- logNormCounts(
  altExp(sce, "Antibody Capture"))
# NOTE: `d = NA` means no dimensionality reduction is performed.
# NOTE: `k = 150` was selected by trial and error to get a reasonable number of 
#       clusters that avoided overclustering the multi-HTO samples.
g <- buildSNNGraph(altExp(sce, "Antibody Capture"), k = 100, d = NA)
clusters <- igraph::cluster_louvain(g)$membership
sce$hto_cluster <- factor(clusters)
hto_cluster_colours <- setNames(
  palette("Okabe-Ito")[seq_len(nlevels(sce$hto_cluster))],
  levels(sce$hto_cluster))
sce$hto_cluster_colours <- hto_cluster_colours[sce$hto_cluster]
```

## Visualize demultiplexing results

Figures \@ref(fig:pca) and \@ref(fig:pca-faceted) use principal component analysis (PCA) to show that five clusters are fairly distinguishable from each other and that there are two additional clusters that are more difficult to resolve.

```{r pca, fig.cap = "PCA plot of the HTO data. Each point represents a cell with the colour explained in the legend.", fig.asp = 1}
set.seed(666)
sce <- runPCA(sce, altexp = "Antibody Capture", name = "PCA_HTO")

plotReducedDim(sce, "PCA_HTO", colour_by = "hto_cluster", point_size = 0) +
  geom_point(aes(colour = colour_by), size = 0.5) +
  scale_colour_manual(values = hto_cluster_colours, name = "hto_cluster") +
  ggtitle("PCA: HTOs") +
  theme_cowplot()
```

```{r pca-faceted, fig.cap = "PCA plot of the HTO data. Each panel highlights cells from a particular cluster.", fig.asp = 1}
pca <- cbind(
  as.data.frame(colData(sce)),
  x = reducedDim(sce, "PCA_HTO")[, 1],
  y = reducedDim(sce, "PCA_HTO")[, 2])
bg <- dplyr::select(pca, -hto_cluster)
ggplot(aes(x = x, y = y), data = pca) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.7), size = 0.1) +
  geom_point(aes(colour = hto_cluster), alpha = 1, size = 0.5) +
  scale_fill_manual(values = hto_cluster_colours, name = "Cluster") + 
  scale_colour_manual(values = hto_cluster_colours, name = "Cluster") +
  theme_cowplot(font_size = 10) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2") +
  facet_wrap(~hto_cluster, ncol = 3, labeller = label_both) +
  theme_cowplot() +
  theme(legend.position = "none")
```

As an alternative to PCA, we can  use a $t$-stochastic neighbour embedding (t-SNE) [@van2008visualizing] to visualise the HTO data in 2-dimensions, overlaying the assigned cluster labels.

```{r}
set.seed(666)
library(Rtsne)
sce <- runTSNE(sce, dimred = "PCA_HTO", name = "TSNE_HTO")
```

Figures \@ref(fig:tsne) and \@ref(fig:tsne-faceted) show that five clusters are clearly distinguishable from each other and that the two additional clusters are a little easier to visually resolve.

```{r tsne, fig.cap = "t-SNE plot of the HTO data. Each point represents a cell with the colour explained in the legend.", fig.asp = 1}
plotReducedDim(sce, "TSNE_HTO", colour_by = "hto_cluster", point_size = 0) +
  geom_point(aes(colour = colour_by), size = 0.5) +
  scale_colour_manual(values = hto_cluster_colours, name = "hto_cluster") +
  ggtitle("t-SNE: HTOs") +
  theme_cowplot()
```

```{r tsne-faceted, fig.cap = "t-SNE plot of the HTO data. Each panel highlights cells from a particular cluster.", fig.asp = 1}
tsne <- cbind(
  as.data.frame(colData(sce)),
  x = reducedDim(sce, "TSNE_HTO")[, 1],
  y = reducedDim(sce, "TSNE_HTO")[, 2])
bg <- dplyr::select(tsne, -hto_cluster)
ggplot(aes(x = x, y = y), data = tsne) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.7), size = 0.1) +
  geom_point(aes(colour = hto_cluster), alpha = 1, size = 0.5) +
  scale_fill_manual(values = hto_cluster_colours, name = "Cluster") + 
  scale_colour_manual(values = hto_cluster_colours, name = "Cluster") +
  theme_cowplot(font_size = 10) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2") +
  facet_wrap(~hto_cluster, ncol = 3, labeller = label_both) +
  theme_cowplot() +
  theme(legend.position = "none")
```

Figure \@ref(fig:heatmap-average) and \@ref(fig:heatmap) show that the five clearly distinguishable clusters correspond to the cells uniquely labelled with a single HTO while the two remaining clusters correspond to the sample labelled with all 5 HTOs and cells labelled with two or more HTOs.

```{r heatmap-average, fig.cap = "Heatmap of row-nomralized average log-expression of HTOs."}
averaged <- sweep(
  assay(
    sumCountsAcrossCells(
      altExp(sce, "Antibody Capture"), 
      sce$hto_cluster, 
      exprs_values = "logcounts")),
  2,
  table(sce$hto_cluster),
  "/")
# Sanity check
stopifnot(all(apply(averaged, 2, which.max) == c(3, 2, 1, 1, 4, 5, 1)))

library(pheatmap)
mat <- averaged - rowMeans(averaged)
rownames(mat) <- rownames(altExp(sce, "Antibody Capture"))
pheatmap(
  mat = mat,
  breaks = seq(-max(abs(mat)), max(abs(mat)), length.out = 101),
  cluster_cols = FALSE,
  cluster_rows = FALSE,
  annotation_col = data.frame(
    cluster = colnames(averaged),
    row.names = colnames(averaged)),
  annotation_colors = list(cluster = hto_cluster_colours),
  color = colorspace::divergex_hcl(n = 100, palette = "RdBu", rev = TRUE))
```

Figure \@ref(fig:violin) plots the expression of each HTO by cluster and confirms that the expression of each HTO is highest in the samples uniquely labelled with that HTO.
Figure \@ref(fig:violin) also reveals that the distribution of expression is very tight (i.e. low variability) for these samples labelled uniquely with that HTO as well as in the samples that were labelled with all 5 HTOs (cluster 5).
In contrast, the samples in cluster 4 often have high expression of each HTO but this expression is much more variable than those samples in cluster 5.

```{r violin, fig.cap = "Expression of HTOs by cluster."}
plotExpression(
  altExp(sce, "Antibody Capture"),
  features = rownames(altExp(sce, "Antibody Capture")),
  x = I(sce$hto_cluster),
  colour_by = I(sce$hto_cluster)) +
  scale_fill_manual(values = hto_cluster_colours) +
  theme_cowplot()
```

## Assignment of HTO clusters to samples

James provided me with a table linking HTOs to samples, shown below.

```{r}
hto_to_sample_df <- data.frame(
  HTO = paste0("human_", c(1:5, paste0(1:5, collapse = "_"))),
  Sample = c(paste0("infected_", 1:3), paste0("uninfected_", 1:3)),
  Treatment = c(rep("Infected", 3), rep("Uninfected", 3)),
  Replicate = rep(1:3, 2))

knitr::kable(hto_to_sample_df, caption = "Table linking HTOs to samples")
```

James was targetting ~2000 cells / sample.
The table below shows that we largely hit that target for the uninfected samples but not so for the infected samples.
It also shows that proportion of droplets that are 'unassigned' (i.e. those in cluster (`r which.max(table(sce$hto_cluster))`) is larger than we would like.

```{r}
# Map clusters to HTOs to samples
# NOTE: This is made by visually inspecting the above heatmaps.
cluster_to_hto_df <- data.frame(
  hto_cluster = factor(levels(sce$hto_cluster)),
  HTO = c(
    "human_3",
    "human_2",
    NA_character_,
    paste0("human_", c(paste0(1:5, collapse = "_"))), 
    "human_4",
    "human_5",
    "human_1"))

hto_df <- left_join(cluster_to_hto_df, hto_to_sample_df)
knitr::kable(
  hto_df %>%
    left_join(
    tabyl(data.frame(hto_cluster = sce$hto_cluster), hto_cluster) %>%
      adorn_pct_formatting(1)) %>%
    dplyr::arrange(Sample), 
  caption = "Tabulation of samples by treatment and replicate (mouse). The samples are unpaired. 'NA' values are those samples who HTOs could not be demultiplexed.")
```

These unassigned droplets likely include true doublets, mis-assigned singlets from the cells labelled with all five HTOs, and samples comparising ambient RNAs/HTOs (aka the 'soup' [@young10soupx]).

```{r}
# NOTE: This is a bit clunky because the colData contains SplitDataFrameList
#       columns that would otherwise not survive the conversion to a data.frame.
tmp <- as.data.frame(colData(sce)[, c("hto_cluster"), drop = FALSE]) %>%
  mutate(hto_cluster = as.character(hto_cluster)) %>%
  left_join(hto_df)
colData(sce) <- cbind(
  colData(sce)[, c("Barcode", "project", "TRA", "TRB")],
  tmp)
```

We will keep these 'unknown' droplets as their own category to see if these cells are transcriptomically distinct, which may indicate an issue with cell hashing for certain types of cells.

# Concluding remarks

```{r}
saveRDS(
  sce,
  here("data", "SCEs", "C057_Cooney.demultiplexed.SCE.rds"),
  compress = "xz")
```

The processed *SingleCellExperiment* object is available (see [`data/SCEs/C057_Cooney.demultiplexed.SCE.rds`](../data/SCEs/C057_Cooney.demultiplexed.SCE.rds)).
This will be used in downstream analyses, e.g., pre-processing.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

<summary>The analysis and this document were prepared using the following software (click triangle to expand)</summary>
<details>

```{r}
sessioninfo::session_info()
```

</details>
