---
title: "Demultiplexing the Cooney (C057) memory CD4+ T-cell data set"
description: |
author:
  - name: Peter Hickey 
    url: https://peterhickey.org
    affiliation: WEHI SCORE
    affiliation_url: https://www.wehi.edu.au/people/shalin-naik/3310/score
date: "`r Sys.Date()`"
output: distill::distill_article
editor_options: 
  chunk_output_type: console
bibliography: ref.bib
---

```{r setup}
library(here)
library(magrittr)
library(BiocStyle)
library(dplyr)
library(janitor)
library(cowplot)

source(here("analysis", "helper_functions.R"))
# NOTE: Using >= 4 cores siezes up my laptop. Can use more on unix box.
options("mc.cores" = ifelse(Sys.info()[["nodename"]] == "PC1331", 2L, 3L))
knitr::opts_chunk$set(fig.path = "C057_Cooney_demultiplex_files/")
```

# Introduction

Cells were obtained from six samples.
These samples were processed a technique called using Cell Hashing, a method that enables sample multiplexing. 
Cell Hashing uses a series of oligo-tagged antibodies against ubiquitously expressed surface proteins with different barcodes to uniquely label cells from distinct samples, which can be subsequently pooled in one scRNA-seq run.
By sequencing these tags alongside the cellular transcriptome, we can assign each cell to its sample of origin, and robustly identify doublets originating from multiple samples.

In a typical Cell Hashing experiment, each sample is uniquely labelled with a single hashtag oligonucleotide (HTO).
However, in this experiment we needed to label 6 samples but only had 5 HTOs.
We decided to uniquely label five of the samples (three infected, two uninfected) with a single HTO and to label the sixth sample with all five HTOs.
This non-standard use of HTOs meant we could not rely on standard cell hashing demultiplexing routines, like that available in `r BiocStyle::CRANpkg("Seurat")`.

# Setting up the data

The count data were processed using **CellRanger** and the `r Biocpkg("DropletUtils")` R/Bioconductor packages.
The counts and their metadata are available in a *SingleCellExperiment* object available as [`data/SCEs/HTLV_GEX_HTO.CellRanger.SCE.rds`](../data/SCEs/HTLV_GEX_HTO.CellRanger.SCE.rds).
These are the *unfiltered* data, i.e. the data includes all potential genes and barcodes.

```{r}
sce <- readRDS(here("data", "SCEs", "HTLV_GEX_HTO.CellRanger.SCE.rds"))
colnames(sce) <- sce$Barcode

# Split the data up into RNA and HTOs
rna <- sce[grepl("ENS", rownames(sce)), ]
hto <- sce[!grepl("ENS", rownames(sce)), ]
counts(hto) <- as.matrix(counts(hto))
```

# Calling cells from empty droplets

An interesting aspect of droplet-based data is that we have no prior knowledge about which droplets (i.e. cell barcodes) actually contain cells, and which are empty. 
Thus, we need to call cells from empty droplets based on the observed RNA expression profiles.

Calling empty droplets is not entirely straightforward as empty droplets can contain ambient (i.e. extracellular) RNA that can be captured and sequenced. 
The distribution of total counts exhibits a sharp transition between barcodes with large and small total counts (Figure \@ref(fig:rankplot)), probably corresponding to cell-containing and empty droplets respectively.

```{r rankplot, fig.cap = "Total UMI count for each barcode in the dataset, plotted against its rank (in decreasing order of total counts). The inferred locations of the inflection (dark green dashed lines) and knee points (blue dashed lines) are also shown."}
library(DropletUtils)
bcrank <- barcodeRanks(counts(rna))
# Only showing unique points for plotting speed.
uniq <- !duplicated(bcrank$rank)
plot(
  x = bcrank$rank[uniq], 
  y = bcrank$total[uniq], 
  log = "xy",
  xlab = "Rank", 
  ylab = "Total UMI count", 
  main = "C041_Lopez",
  cex.lab = 1.2,
  xlim = c(1, 500000),
  ylim = c(1, 50000))
abline(h = metadata(bcrank)$inflection, col = "darkgreen", lty = 2)
abline(h = metadata(bcrank)$knee, col = "dodgerblue", lty = 2)
```

We use the `emptyDrops()` function from the `r Biocpkg("DropletUtils")` package to test whether the expression profile for each cell barcode is significantly different from the ambient RNA pool [@lun2018distinguishing].
This tends to be less conservative than the cell calling algorithm from the **CellRanger** pipeline, which often discards genuine cells with low RNA content (and thus low total counts).
Any significant deviation indicates that the barcode corresponds to a cell-containing droplet.
We call cells at a false discovery rate (FDR) of 0.1%, meaning that no more than 0.1% of our called barcodes should be empty droplets on average.

```{r}
empties <- readRDS(here("data", "emptyDrops", "empties.rds"))
fdr <- 0.001
dplyr::mutate(
  as.data.frame(empties),
  Sample = rep("HTLV_GEX_HTO", nrow(empties))) %>%
  dplyr::group_by(Sample) %>%
  dplyr::summarise(
    keep = sum(FDR < fdr, na.rm = TRUE), 
    n = n(),
    remove = n - keep) %>%
  dplyr::mutate(library = factor(Sample)) %>%
  dplyr::select(library, keep, remove) %>%
  knitr::kable(
    caption = "Number of droplets kept and removed after filtering empty drops.")
sce <- sce[, which(empties$FDR <= fdr)]
# Re-split the data up into RNA and HTOs
rna <- sce[grepl("ENS", rownames(sce)), ]
hto <- sce[!grepl("ENS", rownames(sce)), ]
counts(hto) <- as.matrix(counts(hto))
```

It is worth pointing out that, at this point, we do not attempt to remove the ambient contamination from the remaining libraries.
Accurate quantification of the contamination rate in each cell is difficult as it generally requires some prior biological knowledge about genes that are expected to have mutually exclusive expression profiles and are highly abundant in the ambient solution [@young10soupx].
Fortunately, ambient contamination usually has little effect on the downstream conclusions for routine analyses; cell type identities are usually easy enough to determine from the affected genes, notwithstanding a (mostly harmless) low background level of expression for marker genes that should be unique to a cell type.

# Demultiplexing with hashtag oligos (HTOs)

We only use the droplets identified as non-empty in [Calling cells from empty droplets].

```{r}
# Select cell barcodes detected by both RNA and HTOs
# NOTE: In this case, all droplets are retained because emptyDrops() has
#       already been run on the RNA and because the HTOs were sequenced quite
#       deeply.
rna_bcs <- colSums(assay(rna)) > 0
hto_bcs <- colSums(assay(hto)) > 0
joint_bcs <- rna_bcs & hto_bcs
rna <- rna[, joint_bcs]
hto <- hto[, joint_bcs]
```

These samples were processed using 5 HTOs (`human_1`, `human_2`, `human_3`, `human_4`, and `human_5`).
Nonetheless, we ran **CellRanger** using a larger panel of HTOs (n = `r nrow(hto)`) to enable us to check for background contamination of HTOs.

Figure \@ref(fig:htos) plots the distribution of each HTO counts for those HTOs detected in at least one cell and shows that HTOs `human_1`, `human_2`, `human_3`, `human_4`, and `human_5`, are clearly detected more frequently than the other barcodes, as we would hope.

```{r htos, fig.cap = "Distribution of HTO counts in the dataset. Only those HTOs with more detected in at least one cell are shown. The red vertical line denotes detecting the HTO 10 times in a sample.", layout = "l-page", fig.asp = 4 / 3}
par(mfrow = c(5, 4))
o <- order(rowSums(counts(hto)), decreasing = TRUE)
for (i in o) {
  if (rowSums(counts(hto))[i] > 0) {
    plot(
      table(counts(hto)[i, ]),
      main = rownames(hto)[i],
      xlim = c(1, 10 ^ 5),
      log = "x",
      xlab = "Detections",
      ylab = "Frequency")
    abline(v = 10, col = "red")
  }
}
```

We therefore focus on assigning cells to just the `human_1`, `human_2`, `human_3`, `human_4`, and `human_5` HTOs, along with the combination of all five HTOs.

```{r}
hto <- hto[paste0("human_", 1:5), ]
```

We perform library-size normalization of the HTO counts and then cluster the log-expression of the HTOs to identify samples with similar HTO expression profiles.

```{r}
library(scater)
# Compute size factors
sf_lib <- librarySizeFactors(hto)

library(scran)
sizeFactors(hto) <- sf_lib
hto <- normalizeSCE(hto)
# NOTE: `d = NA` means no dimensionality reduction is performed.
# NOTE: `k = 100` was selected by trial and error to get a reasonable number of 
#       clusters that avoided overclustering the multi-HTO samples.
g <- buildSNNGraph(hto, k = 100, d = NA)
clusters <- igraph::cluster_louvain(g)$membership
hto$cluster <- factor(clusters)
cluster_colours <- setNames(
  colorblindr::palette_OkabeIto,
  levels(hto$cluster))
cluster_colours <- cluster_colours[!is.na(names(cluster_colours))]
```

## Visualize demultiplexing results

Figures \@ref(fig:pca) and \@ref(fig:pca-faceted) use principal component analysis (PCA) to show that five clusters are fairly distinguishable from each other and that there are two additional clusters that are more difficult to resolve.

```{r pca, fig.cap = "PCA plot of the HTO data. Each point represents a cell with the colour explained in the legend.", fig.asp = 1}
set.seed(666)
hto <- runPCA(hto)

plotPCA(hto, colour_by = "cluster", point_size = 0) +
  geom_point(aes(colour = colour_by), size = 0.5) +
  scale_colour_manual(values = cluster_colours, name = "cluster") +
  ggtitle("PCA: HTOs") +
  theme_cowplot()
```

```{r pca-faceted, fig.cap = "PCA plot of the HTO data. Each panel highlights cells from a particular cluster.", fig.asp = 1}
pca <- cbind(
  as.data.frame(colData(hto)),
  x = reducedDim(hto, "PCA")[, 1],
  y = reducedDim(hto, "PCA")[, 2])
bg <- dplyr::select(pca, -cluster)
ggplot(aes(x = x, y = y), data = pca) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.7), size = 0.1) +
  geom_point(aes(colour = cluster), alpha = 1, size = 0.5) +
  scale_fill_manual(values = cluster_colours, name = "Cluster") + 
  scale_colour_manual(values = cluster_colours, name = "Cluster") +
  theme_cowplot(font_size = 10) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2") +
  facet_wrap(~cluster, ncol = 3, labeller = label_both) +
  theme_cowplot() +
  theme(legend.position = "none")
```

As an alternative to PCA, we can  use a $t$-stochastic neighbour embedding (t-SNE) [@van2008visualizing] to visualise the HTO data in 2-dimensions, overlaying the assigned cluster labels.

```{r}
set.seed(666)
hto <- runTSNE(hto)
```

Figures \@ref(fig:tsne) and \@ref(fig:tsne-faceted) show that five clusters are clearly distinguishable from each other and that the two additional clusters are a little easier to visually resolve.

```{r tsne, fig.cap = "t-SNE plot of the HTO data. Each point represents a cell with the colour explained in the legend.", fig.asp = 1}
plotTSNE(hto, colour_by = "cluster", point_size = 0) +
  geom_point(aes(colour = colour_by), size = 0.5) +
  scale_colour_manual(values = cluster_colours, name = "cluster") +
  ggtitle("t-SNE: HTOs") +
  theme_cowplot()
```

```{r tsne-faceted, fig.cap = "t-SNE plot of the HTO data. Each panel highlights cells from a particular cluster.", fig.asp = 1}
tsne <- cbind(
  as.data.frame(colData(hto)),
  x = reducedDim(hto, "TSNE")[, 1],
  y = reducedDim(hto, "TSNE")[, 2])
bg <- dplyr::select(tsne, -cluster)
ggplot(aes(x = x, y = y), data = tsne) +
  geom_point(data = bg, colour = scales::alpha("grey", 0.7), size = 0.1) +
  geom_point(aes(colour = cluster), alpha = 1, size = 0.5) +
  scale_fill_manual(values = cluster_colours, name = "Cluster") + 
  scale_colour_manual(values = cluster_colours, name = "Cluster") +
  theme_cowplot(font_size = 10) + 
  xlab("Dimension 1") + 
  ylab("Dimension 2") +
  facet_wrap(~cluster, ncol = 3, labeller = label_both) +
  theme_cowplot() +
  theme(legend.position = "none")
```

Figure \@ref(fig:heatmap-average) and \@ref(fig:heatmap) show that the five clearly distinguishable clusters correspond to the cells uniquely labelled with a single HTO while the two remaining clusters correspond to the sample labelled with all 5 HTOs and cells labelled with two or more HTOs.

```{r heatmap-average, fig.cap = "Heatmap of row-nomralized average log-expression of HTOs."}
averaged <- sweep(
  sumCountsAcrossCells(hto, clusters, exprs_values = "logcounts"),
  2,
  table(hto$cluster),
  "/")
# Sanity check
stopifnot(all(apply(averaged, 2, which.max) == c(3, 2, 1, 1, 4, 5, 1)))

library(pheatmap)
mat <- averaged - rowMeans(averaged)
rownames(mat) <- rownames(hto)
pheatmap(
  mat = mat,
  breaks = seq(-max(abs(mat)), max(abs(mat)), length.out = 101),
  cluster_cols = FALSE,
  cluster_rows = FALSE,
  annotation_col = data.frame(
    cluster = colnames(averaged),
    row.names = colnames(averaged)),
  annotation_colors = list(cluster = cluster_colours),
  color = colorspace::divergex_hcl(n = 100, palette = "RdBu", rev = TRUE))
```

```{r heatmap, fig.cap = "Heatmap of row-normalized log-expression of HTOs."}
.plotHeatmap(
  object = hto,
  features = rownames(hto),
  columns = order(hto$cluster),
  colour_columns_by = "cluster",
  cluster_cols = FALSE,
  cluster_rows = FALSE,
  center = TRUE,
  symmetric = TRUE,
  show_colnames = FALSE,
  fontsize = 8,
  annotation_colors = list(cluster = cluster_colours),
  color = colorspace::divergex_hcl(n = 100, palette = "RdBu", rev = TRUE))
```

Figure \@ref(fig:violin) plots the expression of each HTO by cluster and confirms that the expression of each HTO is highest in the samples uniquely labelled with that HTO.
Figure \@ref(fig:violin) also reveals that the distribution of expression is very tight (i.e. low variability) for these samples labelled uniquely with that HTO as well as in the samples that were labelled with all 5 HTOs (cluster 5).
In contrast, the samples in cluster 4 often have high expression of each HTO but this expression is much more variable than those samples in cluster 5.

```{r violin, fig.cap = "Expression of HTOs by cluster."}
plotExpression(
  hto,
  features = paste0("human_", 1:5),
  x = "cluster",
  colour_by = "cluster") +
  scale_fill_manual(values = cluster_colours) +
  theme_cowplot()
```

## Assignment of HTO clusters to samples

James provided me with a table linking HTOs to samples, shown below.

```{r}
hto_to_sample_df <- data.frame(
  HTO = paste0("human_", c(1:5, paste0(1:5, collapse = "_"))),
  Sample = c(paste0("infected_", 1:3), paste0("uninfected_", 1:3)),
  Treatment = c(rep("Infected", 3), rep("Uninfected", 3)),
  Replicate = rep(1:3, 2),
  stringsAsFactors = FALSE)

knitr::kable(hto_to_sample_df, caption = "Table linking HTOs to samples")
```

James was targetting ~2000 cells / sample.
The table below shows that we largely hit that target for the uninfected samples but not so for the infected samples.
It also shows that proportion of droplets that are 'unassigned' (i.e. those in cluster (`r which.max(table(hto$cluster))`) is larger than we would like.

```{r}
# Map clusters to HTOs to samples
# NOTE: This is made by visually inspecting the above heatmaps.
cluster_to_hto_df <- data.frame(
  cluster = levels(hto$cluster),
  HTO = c(
    paste0("human_", c(3, 2)),
    NA_character_, 
    paste0("human_", c(paste0(1:5, collapse = "_"), 4, 5, 1))),
  stringsAsFactors = FALSE)

hto_df <- left_join(cluster_to_hto_df, hto_to_sample_df)
knitr::kable(
  hto_df %>%
    left_join(
    tabyl(data.frame(cluster = hto$cluster), cluster) %>%
      adorn_pct_formatting(1)) %>%
    dplyr::arrange(Sample), 
  caption = "Tabulation of samples by treatment and replicate (mouse). The samples are unpaired. 'NA' values are those samples who HTOs could not be demultiplexed.")
```

These unassigned droplets likely include true doublets, mis-assigned singlets from the cells labelled with all five HTOs, and samples comparising ambient RNAs/HTOs (aka the 'soup' [@young10soupx]).

```{r}
stopifnot(identical(colnames(sce), colnames(hto)))
colData(sce) <- colData(sce) %>%
  as.data.frame() %>%
  select(-Sample) %>%
  dplyr::mutate(cluster = hto$cluster) %>%
  left_join(hto_df) %>%
  dplyr::rename(hto_cluster = cluster) %>%
  DataFrame(row.names = colnames(sce))
```

```{r pairs, fig.cap = "Pairwise expression of HTOs coloured by assigned by cluster.", eval = FALSE}
# NOTE: Not using this figure (it's really a poor man's PCA or tSNE). It shows
#       in most panels that there is a small group of cells that express 2 HTOs
#       but have been assigned to one of the single HTO clusters.
pairs(
  t(logcounts(hto)),
  col = scales::alpha(cluster_colours, c(0.1, 0.1, 0.1, 1, 0.1, 0.1, 0.1))[hto$cluster],
  pch = 16,
  cex = 0.5,
  text.panel = function(x = 0.5, y = 0.5, txt, cex, font) {
    col <- cluster_colours[cluster_to_hto_df[which(
      cluster_to_hto_df$HTO == txt), "cluster"]]
    text(x, y, txt, cex = cex, font = font, col = col)
  },
  upper.panel = NULL)
```

We will keep these 'unknown' droplets as their own category to see if these cells are transcriptomically distinct, which may indicate an issue with cell hashing for certain types of cells.

# Concluding remarks

```{r}
saveRDS(
  sce,
  here("data", "SCEs", "C057_Cooney.demultiplexed.SCE.rds"),
  compress = "xz")
```

The processed *SingleCellExperiment* object is available (see [`data/SCEs/C057_Cooney.demultiplexed.SCE.rds`](../data/SCEs/C057_Cooney.demultiplexed.SCE.rds)).
This will be used in downstream analyses, e.g., pre-processing.

# Additional information {.appendix}

The following are available on request:

- Full CSV tables of any data presented.
- PDF/PNG files of any static plots.

# Session info {.appendix}

The analysis and this document were prepared using the following software:

```{r}
sessionInfo()
```
